<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Smash / Blade Ball</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #222;
    user-select: none;
  }
  canvas {
    display: block;
    background: linear-gradient(#444, #222);
    margin: 0 auto;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #eee;
    font-family: Arial, sans-serif;
    font-weight: bold;
    font-size: 18px;
    user-select: none;
  }
  #ui > div {
    margin-bottom: 4px;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="450"></canvas>
<div id="ui">
  <div>Player 1 Damage: <span id="p1damage">0%</span></div>
  <div>Player 2 Damage: <span id="p2damage">0%</span></div>
  <div>Controls:</div>
  <div>P1: WASD to move, F to punch, G to block</div>
  <div>P2: Arrow keys to move, K to punch, L to block</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Game constants
  const PLAYER_SIZE = 40;
  const BALL_RADIUS = 15;
  const GRAVITY = 0.5; // for knockback arcs
  const FRICTION = 0.85;

  // Players state
  class Player {
    constructor(x, y, controls, color) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.width = PLAYER_SIZE;
      this.height = PLAYER_SIZE;
      this.color = color;
      this.damage = 0;
      this.controls = controls;
      this.isPunching = false;
      this.isBlocking = false;
      this.facing = 1; // 1=right, -1=left
      this.onGround = true;
      this.knockback = {x: 0, y: 0};
      this.hitCooldown = 0;
      this.score = 0;
    }

    update() {
      // Apply knockback velocity
      if (this.knockback.x !== 0 || this.knockback.y !== 0) {
        this.x += this.knockback.x;
        this.y += this.knockback.y;
        this.knockback.y += GRAVITY;
        this.knockback.x *= FRICTION;
        this.knockback.y *= FRICTION;

        if (this.y + this.height >= HEIGHT - 20) {
          this.y = HEIGHT - 20 - this.height;
          this.knockback.y = 0;
          this.knockback.x *= 0.5;
        }

        // Reduce knockback if small
        if (Math.abs(this.knockback.x) < 0.1) this.knockback.x = 0;
      } else {
        // Normal movement controls only when no knockback
        if (this.hitCooldown <= 0) {
          if (this.controls.left) {
            this.vx = -5;
            this.facing = -1;
          } else if (this.controls.right) {
            this.vx = 5;
            this.facing = 1;
          } else {
            this.vx = 0;
          }

          if (this.controls.up && this.onGround) {
            this.vy = -12;
            this.onGround = false;
          }
        }

        this.x += this.vx;
        this.y += this.vy;

        if (!this.onGround) {
          this.vy += GRAVITY;
        }

        if (this.y + this.height >= HEIGHT - 20) {
          this.y = HEIGHT - 20 - this.height;
          this.vy = 0;
          this.onGround = true;
        }
      }

      // Boundaries
      if (this.x < 0) this.x = 0;
      if (this.x + this.width > WIDTH) this.x = WIDTH - this.width;

      if (this.hitCooldown > 0) this.hitCooldown--;

      // Punch duration auto reset
      if (this.isPunching) {
        this.punchTimer--;
        if (this.punchTimer <= 0) this.isPunching = false;
      }
    }

    punch() {
      if (!this.isPunching && this.hitCooldown <= 0) {
        this.isPunching = true;
        this.punchTimer = 10;
      }
    }

    block(isBlocking) {
      this.isBlocking = isBlocking;
    }

    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);

      // Draw punch hitbox if punching
      if (this.isPunching) {
        ctx.fillStyle = 'orange';
        const punchWidth = 20;
        const punchHeight = 20;
        const punchX = this.facing === 1 ? this.x + this.width : this.x - punchWidth;
        const punchY = this.y + this.height / 2 - punchHeight / 2;
        ctx.fillRect(punchX, punchY, punchWidth, punchHeight);
      }

      // Draw block shield
      if (this.isBlocking) {
        ctx.strokeStyle = '#0af';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  // Ball class
  class Ball {
    constructor() {
      this.x = WIDTH / 2;
      this.y = HEIGHT / 2;
      this.vx = 6 * (Math.random() > 0.5 ? 1 : -1);
      this.vy = 0;
      this.radius = BALL_RADIUS;
      this.lastHitter = null;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;

      this.vy += GRAVITY * 0.3;

      if (this.y + this.radius > HEIGHT - 20) {
        this.y = HEIGHT - 20 - this.radius;
        this.vy = -this.vy * 0.7;
      }

      if (this.x - this.radius < 0) {
        this.x = this.radius;
        this.vx = -this.vx;
      }
      if (this.x + this.radius > WIDTH) {
        this.x = WIDTH - this.radius;
        this.vx = -this.vx;
      }
    }

    draw() {
      ctx.fillStyle = '#f3da0b';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#b38f00';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  }

  // Instantiate players and ball
  const p1 = new Player(100, HEIGHT - PLAYER_SIZE - 20, {left:false, right:false, up:false, punch:false, block:false}, '#f34b4b');
  const p2 = new Player(WIDTH - 140, HEIGHT - PLAYER_SIZE - 20, {left:false, right:false, up:false, punch:false, block:false}, '#4b9ef3');
  const ball = new Ball();

  // Update UI damage
  const p1damageEl = document.getElementById('p1damage');
  const p2damageEl = document.getElementById('p2damage');

  // Controls mapping
  const keysDown = {};

  // Handle keyboard input
  window.addEventListener('keydown', e => {
    keysDown[e.key.toLowerCase()] = true;
    handleControls();
  });
  window.addEventListener('keyup', e => {
    keysDown[e.key.toLowerCase()] = false;
    handleControls();
  });

  function handleControls() {
    // P1 controls: WASD + F punch, G block
    p1.controls.left = keysDown['a'] || false;
    p1.controls.right = keysDown['d'] || false;
    p1.controls.up = keysDown['w'] || false;
    if(keysDown['f']) p1.punch();
    p1.block(keysDown['g']);

    // P2 controls: arrow keys + K punch, L block
    p2.controls.left = keysDown['arrowleft'] || false;
    p2.controls.right = keysDown['arrowright'] || false;
    p2.controls.up = keysDown['arrowup'] || false;
    if(keysDown['k']) p2.punch();
    p2.block(keysDown['l']);
  }

  // Collision helper
  function rectsIntersect(a, b) {
    return !(b.x > a.x + a.width ||
             b.x + b.width < a.x ||
             b.y > a.y + a.height ||
             b.y + b.height < a.y);
  }

  // Ball-circle collision with player rectangle
  function ballHitsPlayer(ball, player) {
    // Closest point on player rectangle to ball center
    const closestX = Math.max(player.x, Math.min(ball.x, player.x + player.width));
    const closestY = Math.max(player.y, Math.min(ball.y, player.y + player.height));

    const dx = ball.x - closestX;
    const dy = ball.y - closestY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist < ball.radius;
  }

  // Player punch hitbox rectangle
  function getPunchHitbox(player) {
    if (!player.isPunching) return null;
    const punchWidth = 20;
    const punchHeight = 20;
    const punchX = player.facing === 1 ? player.x + player.width : player.x - punchWidth;
    const punchY = player.y + player.height / 2 - punchHeight / 2;
    return {x: punchX, y: punchY, width: punchWidth, height: punchHeight};
  }

  // Knockback calculation
  function applyKnockback(player, forceX, forceY) {
    player.knockback.x = forceX;
    player.knockback.y = forceY;
  }

  // Check player punch vs other player
  function checkPunch(attacker, defender) {
    if (!attacker.isPunching) return;
    if (attacker.hitCooldown > 0) return;

    const punchBox = getPunchHitbox(attacker);
    const defenderBox = {x: defender.x, y: defender.y, width: defender.width, height: defender.height};

    if (rectsIntersect(punchBox, defenderBox)) {
      if (defender.isBlocking) {
        // Blocking reduces damage and knockback
        defender.damage += 2;
        defender.hitCooldown = 15;
        applyKnockback(defender, attacker.facing * 2, -5);
      } else {
        defender.damage += 8;
        defender.hitCooldown = 30;
        // Knockback force scales with damage
        const kbForceX = attacker.facing * (5 + defender.damage / 5);
        const kbForceY = -8;
        applyKnockback(defender, kbForceX, kbForceY);
      }
      attacker.isPunching = false; // punch hits once per punch action
    }
  }

  // Check ball collision with players
  function checkBallHit(player) {
    if (!ballHitsPlayer(ball, player)) return false;

    // If player is blocking, reflect ball with less damage to player
    if (player.isBlocking) {
      ball.vx = -ball.vx * 1.2;
      ball.vy = -5;
      ball.lastHitter = player;
      player.damage += 2;
      return true;
    }

    // If player punching and ball is near punch hitbox, reflect with more force
    const punchBox = getPunchHitbox(player);
    if (player.isPunching && punchBox) {
      // Check if punch hits ball (circle-rect collision)
      const closestX = Math.max(punchBox.x, Math.min(ball.x, punchBox.x + punchBox.width));
      const closestY = Math.max(punchBox.y, Math.min(ball.y, punchBox.y + punchBox.height));
      const dx = ball.x - closestX;
      const dy = ball.y - closestY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < ball.radius) {
        ball.vx = player.facing * (7 + player.damage / 5);
        ball.vy = -5;
        ball.lastHitter = player;
        return true;
      }
    }

    // Ball hits player normally = damage and knockback
    player.damage += 10;
    const kbForceX = ball.vx > 0 ? 5 + player.damage / 3 : -5 - player.damage / 3;
    const kbForceY = -10;
    applyKnockback(player, kbForceX, kbForceY);

    // Bounce ball back
    ball.vx = -ball.vx;
    ball.vy = -5;
    ball.lastHitter = null;
    return true;
  }

  // Check if player is knocked out (off stage)
  function checkKnockout(player) {
    if (player.y > HEIGHT + 50) {
      return true;
    }
    return false;
  }

  // Reset players to center
  function resetPositions() {
    p1.x = 100; p1.y = HEIGHT - PLAYER_SIZE - 20;
    p1.vx = 0; p1.vy = 0;
    p1.knockback = {x: 0, y: 0};
    p1.damage = 0;
    p1.hitCooldown = 0;

    p2.x = WIDTH - 140; p2.y = HEIGHT - PLAYER_SIZE - 20;
    p2.vx = 0; p2.vy = 0;
    p2.knockback = {x: 0, y: 0};
    p2.damage = 0;
    p2.hitCooldown = 0;

    ball.x = WIDTH / 2;
    ball.y = HEIGHT / 2;
    ball.vx = 6 * (Math.random() > 0.5 ? 1 : -1);
    ball.vy = 0;
    ball.lastHitter = null;
  }

  // Game loop
  function loop() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw stage floor
    ctx.fillStyle = '#444';
    ctx.fillRect(0, HEIGHT - 20, WIDTH, 20);

    p1.update();
    p2.update();
    ball.update();

    // Check punches
    checkPunch(p1, p2);
    checkPunch(p2, p1);

    // Check ball hits players
    checkBallHit(p1);
    checkBallHit(p2);

    // Draw players and ball
    p1.draw();
    p2.draw();
    ball.draw();

    // Update damage UI
    p1damageEl.textContent = p1.damage.toFixed(0) + '%';
    p2damageEl.textContent = p2.damage.toFixed(0) + '%';

    // Check knockouts
    if (checkKnockout(p1)) {
      alert("Player 2 Wins!");
      resetPositions();
    } else if (checkKnockout(p2)) {
      alert("Player 1 Wins!");
      resetPositions();
    }

    requestAnimationFrame(loop);
  }

  resetPositions();
  loop();
})();
</script>

</body>
</html>
