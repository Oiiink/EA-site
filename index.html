<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Color Wordle â€” 1,000 Colors (Fixed & Hardened)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.googleapis.com">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

  :root{
    --bg:#0b0b0b;
    --card:#111214;
    --accent:#ff9a00;
    --muted:#9aa0a6;
    color-scheme: dark;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:
      radial-gradient(900px 500px at 8% 10%, rgba(255,154,0,0.03), transparent 8%),
      linear-gradient(180deg,#0b0b0b 0%, #070707 100%);
    color:#EAF0F6;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:28px;
    box-sizing:border-box;
  }

  .app{
    width:820px;
    max-width:calc(100% - 48px);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.002));
    border-radius:14px;
    padding:20px;
    box-shadow: 0 16px 60px rgba(0,0,0,0.6);
    border:1px solid rgba(255,255,255,0.02);
  }

  .header{display:flex;align-items:center;gap:12px}
  h1{ margin:0; color:var(--accent); font-size:22px; letter-spacing:-0.2px; }
  .lead{ margin:8px 0 14px 0; color:var(--muted); font-size:14px; }

  .controls{ display:flex; gap:12px; align-items:center; }
  .inputWrap{ position:relative; flex:1; }
  #colorInput{
    width:100%; padding:14px 16px; border-radius:12px;
    border:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg,#0f1112,#0b0b0b);
    color:#fff; font-size:16px; outline:none;
  }
  #colorInput:focus{ box-shadow: 0 8px 24px rgba(255,154,0,0.06); border-color: rgba(255,154,0,0.18); }

  .actions{ display:flex; gap:8px; align-items:center; }
  .btn {
    padding:10px 14px; border-radius:10px; border:none; cursor:pointer;
    background:linear-gradient(180deg,var(--accent), #ff7f00); color:#07120a; font-weight:700;
  }
  .mutebtn{ padding:10px 12px; border-radius:10px; background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03); cursor:pointer; font-weight:600; }

  .preview{ width:76px; height:76px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); background:#000; }

  .hint{ color:var(--muted); font-size:13px; margin-top:10px; }

  .main{ display:flex; gap:18px; margin-top:16px; }
  .leftCol{ width:340px; min-width:260px; }
  .rightCol{ flex:1; min-width:360px; max-height:62vh; overflow:auto; padding-right:6px; }

  .card{ background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.003)); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.02); }

  .secretPreview{ display:flex; gap:12px; align-items:center; }
  .bigSwatch{ width:120px; height:120px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); background:#000; }
  .secretMeta{ color:var(--muted); font-size:14px; }

  #guessList{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
  .guessRow{
    display:flex; align-items:center; gap:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.002));
    border-radius:10px; padding:10px; border:1px solid rgba(255,255,255,0.02);
    transition: transform .12s ease, box-shadow .12s ease;
  }
  .guessRow:hover{ transform: translateY(-3px); box-shadow: 0 8px 34px rgba(0,0,0,0.5); }

  .swatch{ width:56px; height:56px; border-radius:8px; border:2px solid rgba(255,255,255,0.04); flex-shrink:0; cursor:pointer; }
  .meta{ flex:1; }
  .meta .name{ font-weight:700; color:#fff; font-size:15px; }
  .meta .hex{ font-size:12px; color:var(--muted); margin-top:6px; }
  .pct{ font-weight:800; min-width:70px; text-align:right; color:#fff; font-size:15px; }

  .correct{ box-shadow: 0 0 22px rgba(0,255,128,0.08); border-color:#19d119; }

  .suggestions{
    position:absolute; left:0; right:0; top:calc(100% + 8px); background:#0e0f10;
    border-radius:10px; border:1px solid rgba(255,255,255,0.03); z-index:60; max-height:220px; overflow:auto; display:none;
  }
  .sugg{ padding:10px 12px; cursor:pointer; color:#eaeff3; }
  .sugg:hover{ background:#121314; }

  .statsRow{ display:flex; gap:12px; align-items:center; margin-top:12px; color:var(--muted); font-size:13px; }
  .footer{ margin-top:12px; color:var(--muted); font-size:13px; text-align:center; }

  @media (max-width:920px){
    .app{ width:calc(100% - 28px); padding:16px; }
    .main{ flex-direction:column; }
    .leftCol, .rightCol{ width:100% }
    .bigSwatch{ width:100px; height:100px }
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Color Wordle">
    <div class="header">
      <h1>Color Wordle â€” 1,000 Colors</h1>
    </div>

    <div class="lead">Type any color phrase. Press <kbd style="background:#111;padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);">Enter</kbd> to submit. Duplicates blocked. Click swatches to copy hex.</div>

    <div class="controls">
      <div class="inputWrap">
        <input id="colorInput" placeholder="Try: 'icy lavender', 'deep sapphire', 'hot pink', '#ff33aa'">
        <div id="suggestions" class="suggestions" aria-hidden="true"></div>
      </div>

      <div class="actions">
        <div id="preview" class="preview" title="Preview"></div>
        <button id="giveBtn" class="btn" title="Reveal secret color">Give up</button>
        <button id="refreshBtn" class="mutebtn" title="Pick new secret">Refresh</button>
      </div>
    </div>

    <div class="hint">Autosuggest supports the 1,000-color DB. If the typed phrase is a hex or CSS name it will be parsed correctly.</div>

    <div class="main">
      <div class="leftCol">
        <div class="card secretCard">
          <div class="secretPreview">
            <div class="bigSwatch" id="secretSwatch" title="Secret preview (hidden until give up)"></div>
            <div>
              <div style="font-weight:800;color:var(--accent);font-size:18px" id="secretName">Secret</div>
              <div class="secretMeta" id="secretHex">â€¢â€¢â€¢â€¢â€¢â€¢</div>
              <div style="margin-top:8px;color:var(--muted);font-size:13px">Tip: secret picked securely (crypto) from the DB. Hidden until you give up.</div>
              <div class="statsRow">
                <div id="totalGuesses">Total guesses: 0</div>
                <div id="uniqueColors" style="opacity:0.85">Unique colors guessed: 0</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="rightCol">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:700">Your Guesses</div>
            <div style="font-size:13px;color:var(--muted)">Matches shown as % (perceptual)</div>
          </div>

          <div id="guessList"></div>
        </div>
      </div>
    </div>

    <div class="footer">1,000 realistic color names generated locally â€” works offline and on GitHub Pages.</div>
  </div>

<script>
/*
  Full client-side game.
  - COLOR_DB generated deterministically from PRNG seed for names,
    but secret is chosen via crypto RNG so it is not trivially predictable.
  - All maps and runtime state live inside this IIFE closure (not on window).
  - No console logs of the secret.
  - Duplicate detection by normalized hex and typed string.
  - Similarity computed with CIE Î”E (Lab) for perceptual accuracy.
*/

(() => {
  'use strict';

  /* -------------------------
     Deterministic name generator
     (generates the 1,000 human-style names)
     ------------------------- */

  function mulberry32(seed) {
    return function() {
      seed |= 0;
      seed = seed + 0x6D2B79F5 | 0;
      var t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  const ADJ = [ "soft","muted","pale","light","deep","rich","vivid","bright","neon","dusty","warm","cool","icy","smoky","frost","velvet","silken","dusky","dawn","dusk","ember","solar","lunar","midnight","ocean","sea","storm","sage","mint","sagebrush","crimson","ruby","coral","peach","amber","sunset","rose","blush","cotton","ivory","ash","charcoal","onyx","cerulean","azure","sapphire","cerise","orchid","lavender","berry","plum","teal","aqua","jade","forest","pine","olive","moss","fern","copper","bronze","stone","sand","beach","oyster","latte","mocha","cherry","maroon","electric","pastel","ghost","opal","pearl","crystal","citrine","topaz","obsidian","galaxy" ];
  const MOD = [ "light","dark","very","extra","soft","deep","pale","bright","muted","warm","cool","dusty","vivid","faded","neon" ];
  const NOUN = [ "sky","sapphire","lilac","lavender","rose","pearl","dawn","dusk","ember","sun","sand","sea","ocean","wave","mint","forest","leaf","moss","jade","sage","pine","berry","plum","violet","orchid","candy","blossom","coral","flame","brick","stone","ash","smoke","shadow","cloud","storm","crown","silk","velvet","cream","latte","copper","amber","haze","mist","glass","glisten","frost","ice","glow","sunset","marigold","chartreuse","cerulean","indigo" ];

  // deterministic PRNG seed (for name generation only)
  const seedRng = mulberry32(0xC0FFEE);
  function pick(arr) { return arr[Math.floor(seedRng() * arr.length)]; }

  function generateNames(count) {
    const set = new Set();
    const names = [];
    let attempts = 0;
    while (names.length < count && attempts < count * 10) {
      attempts++;
      const style = Math.floor(seedRng() * 4);
      let name;
      if (style === 0) {
        name = `${pick(ADJ)} ${pick(NOUN)}`;
      } else if (style === 1) {
        name = `${pick(MOD)} ${pick(ADJ)} ${pick(NOUN)}`;
      } else if (style === 2) {
        name = `${pick(NOUN)} ${pick(NOUN)}`;
      } else {
        name = `${pick(ADJ)} ${pick(NOUN)}`;
      }
      name = name.replace(/\s+/g,' ').trim();
      if (/\b(\w+)\s+\1\b/.test(name)) name = name.replace(/\b(\w+)\s+\1\b/, "$1");
      if (!set.has(name)) { set.add(name); names.push(name); }
    }
    return names;
  }

  // simple deterministic hash => 24-bit color
  function hexFromName(name) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < name.length; i++) {
      h ^= name.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    const r = (h >>> 16) & 0xFF;
    const g = (h >>> 8) & 0xFF;
    const b = h & 0xFF;
    return "#" + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
  }

  // Build name->hex and hex->displayName maps
  const COLOR_DB = (function(){
    const COUNT = 1000;
    const names = generateNames(COUNT);
    const nameToHex = Object.create(null);
    const hexToName = Object.create(null);
    for (let i=0;i<names.length;i++){
      const display = names[i];
      const hex = hexFromName(display);
      const key = display.toLowerCase();
      // do not overwrite existing hex->name mapping (first wins)
      if (!hexToName[hex.toLowerCase()]) hexToName[hex.toLowerCase()] = display;
      nameToHex[key] = hex;
    }
    // freeze maps to make casual tampering harder
    Object.freeze(nameToHex);
    Object.freeze(hexToName);
    return { nameToHex, hexToName };
  })();

  /* -------------------------
     Color conversion helpers (RGB -> XYZ -> Lab) and Î”E
     ------------------------- */

  function hexNormalize(h){
    if(!h) return null;
    let s = String(h).replace('#','').trim();
    if(s.length === 3) s = s.split('').map(c=>c+c).join('');
    if(!/^[0-9a-f]{6}$/i.test(s)) return null;
    return "#" + s.toLowerCase();
  }

  function hexToRgb(hex){
    const h = hexNormalize(hex);
    if (!h) return null;
    const s = h.replace('#','');
    const n = parseInt(s,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }

  function srgbToLinear(v){ // 0..1 -> linear
    if (v <= 0.04045) return v / 12.92;
    return Math.pow((v + 0.055) / 1.055, 2.4);
  }

  function rgbToXyz({r,g,b}){
    // convert 0..255 to 0..1
    const R = srgbToLinear(r/255);
    const G = srgbToLinear(g/255);
    const B = srgbToLinear(b/255);
    // sRGB D65
    const X = R * 0.4124564 + G * 0.3575761 + B * 0.1804375;
    const Y = R * 0.2126729 + G * 0.7151522 + B * 0.0721750;
    const Z = R * 0.0193339 + G * 0.1191920 + B * 0.9503041;
    return { X: X * 100, Y: Y * 100, Z: Z * 100 };
  }

  function xyzToLab({X,Y,Z}) {
    // D65 white point
    const Xn = 95.047, Yn = 100.000, Zn = 108.883;
    let x = X / Xn, y = Y / Yn, z = Z / Zn;
    function f(t){ return t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16/116); }
    const fx = f(x), fy = f(y), fz = f(z);
    const L = (116 * fy) - 16;
    const a = 500 * (fx - fy);
    const b = 200 * (fy - fz);
    return { L: L, a: a, b: b };
  }

  function rgbToLab(rgb){
    const xyz = rgbToXyz(rgb);
    return xyzToLab(xyz);
  }

  function deltaE76(labA, labB){
    const dL = labA.L - labB.L;
    const da = labA.a - labB.a;
    const db = labA.b - labB.b;
    return Math.sqrt(dL*dL + da*da + db*db);
  }

  // Map Î”E to percent similarity: Î”E 0 => 100%; Î”E >= 100 => 0%
  function deltaEPercent(labA, labB){
    const d = deltaE76(labA, labB);
    const pct = Math.round((1 - Math.min(1, d / 100)) * 100);
    return Math.max(0, Math.min(100, pct));
  }

  /* -------------------------
     UI elements (cached)
     ------------------------- */
  const input = document.getElementById('colorInput');
  const suggBox = document.getElementById('suggestions');
  const preview = document.getElementById('preview');
  const guessList = document.getElementById('guessList');
  const secretNameEl = document.getElementById('secretName');
  const secretHexEl = document.getElementById('secretHex');
  const secretSwatch = document.getElementById('secretSwatch');
  const giveBtn = document.getElementById('giveBtn');
  const refreshBtn = document.getElementById('refreshBtn');
  const totalGuessesEl = document.getElementById('totalGuesses');
  const uniqueColorsEl = document.getElementById('uniqueColors');

  /* -------------------------
     Secure secret selection
     ------------------------- */
  let secretName = null;
  let secretHex = null;
  let secretLab = null;

  function securePickSecret(){
    const keys = Object.keys(COLOR_DB.nameToHex);
    const arrLen = keys.length;
    const u32 = new Uint32Array(1);
    window.crypto.getRandomValues(u32);
    const idx = u32[0] % arrLen;
    const nameLower = keys[idx];
    const hex = COLOR_DB.nameToHex[nameLower];
    secretName = COLOR_DB.hexToName[hex.toLowerCase()] || nameLower;
    secretHex = hexNormalize(hex);
    const rgb = hexToRgb(secretHex);
    secretLab = rgbToLab(rgb);
    secretNameEl.textContent = "Secret";
    secretHexEl.textContent = "â€¢â€¢â€¢â€¢â€¢â€¢";
    secretSwatch.style.background = "#000";
  }

  /* -------------------------
     CSS color -> hex helper (robust)
     returns "#rrggbb" or null
     ------------------------- */
  function cssColorToHex(s){
    if (!s || typeof s !== 'string') return null;
    // quick try: use canvas fillStyle (returns normalized value in most browsers)
    try {
      const ctx = document.createElement('canvas').getContext('2d');
      ctx.fillStyle = s;
      const val = ctx.fillStyle; // may be "#rrggbb" or "rgb(...)"
      if (typeof val === 'string' && val[0] === '#') {
        return hexNormalize(val);
      }
      // fallback to computed rgb parsing (handles "rgb(..)" or color keywords)
      const el = document.createElement('div');
      el.style.color = s;
      el.style.display = 'none';
      document.body.appendChild(el);
      const cs = getComputedStyle(el).color; // "rgb(r,g,b)" or "rgba(...)"
      document.body.removeChild(el);
      const m = cs.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!m) return null;
      const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]);
      return "#" + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
    } catch(e){
      return null;
    }
  }

  /* -------------------------
     Lookup helpers
     ------------------------- */
  function lookupHexForInput(raw){
    if(!raw) return null;
    const t = raw.trim();
    // direct hex
    const hx = hexNormalize(t);
    if (hx) return hx;
    // css color name parse
    const cssHex = cssColorToHex(t);
    if (cssHex) return cssHex;
    // DB exact case-insensitive
    const low = t.toLowerCase();
    if (COLOR_DB.nameToHex[low]) return COLOR_DB.nameToHex[low];
    // collapse spaces/hyphens
    const collapse = low.replace(/[\s\-_]+/g,' ');
    if (COLOR_DB.nameToHex[collapse]) return COLOR_DB.nameToHex[collapse];
    // token fuzzy: require all tokens appear in DB name
    const tokens = collapse.split(/\s+/).filter(Boolean);
    if (tokens.length){
      const keys = Object.keys(COLOR_DB.nameToHex);
      for (const k of keys){
        let lk = k;
        let matched = tokens.every(tok => lk.includes(tok));
        if (matched) return COLOR_DB.nameToHex[k];
      }
    }
    return null;
  }

  function lookupNameForHex(hex){
    const h = hexNormalize(hex);
    if (!h) return null;
    return COLOR_DB.hexToName[h.toLowerCase()] || null;
  }

  /* -------------------------
     Guess bookkeeping
     ------------------------- */
  let typedSet = new Set(); // typed strings lowercased
  let normSet = new Set();  // normalized hex strings
  let totalGuesses = 0;

  function updateStats(){
    totalGuessesEl.textContent = `Total guesses: ${totalGuesses}`;
    uniqueColorsEl.textContent = `Unique colors guessed: ${normSet.size}`;
  }

  function addGuessRow(typed, hex, pct){
    const row = document.createElement('div');
    row.className = 'guessRow';
    const sw = document.createElement('div');
    sw.className = 'swatch';
    sw.style.background = hex;
    sw.title = `Click to copy ${hex}`;
    sw.addEventListener('click', ()=> {
      navigator.clipboard?.writeText(hex);
      showHint(`Copied ${hex} to clipboard`);
    });

    const meta = document.createElement('div'); meta.className = 'meta';
    const nm = document.createElement('div'); nm.className = 'name';
    nm.textContent = typed;
    const hx = document.createElement('div'); hx.className = 'hex';
    const canonical = lookupNameForHex(hex);
    hx.textContent = `${hex}${canonical ? ' â€” ' + canonical : ''}`;

    meta.appendChild(nm); meta.appendChild(hx);

    const pctEl = document.createElement('div'); pctEl.className = 'pct';
    pctEl.textContent = pct + '%';

    row.appendChild(sw); row.appendChild(meta); row.appendChild(pctEl);

    if (pct === 100) row.classList.add('correct');

    // newest on top
    guessList.prepend(row);
  }

  let hintTimer = 0;
  function showHint(msg){
    const h = document.querySelector('.hint');
    if (!h) return;
    h.textContent = msg;
    clearTimeout(hintTimer);
    hintTimer = setTimeout(()=>{ h.textContent = "Autosuggest supports the 1,000-color DB. If typed phrase is a hex or CSS name it will be parsed correctly."; }, 3000);
  }

  /* -------------------------
     Input & autosuggest
     ------------------------- */
  input.addEventListener('input', () => {
    const q = input.value.trim().toLowerCase();
    // live preview: if hex or CSS color
    const direct = hexNormalize(q) || cssColorToHex(q);
    preview.style.background = direct || '#000';

    // suggestions from DB
    suggBox.innerHTML = '';
    if(!q){ suggBox.style.display = 'none'; return; }
    const keys = Object.keys(COLOR_DB.nameToHex);
    const starts = [], includes = [];
    for (let i=0;i<keys.length;i++){
      const k = keys[i];
      if (k.startsWith(q)) starts.push(k);
      else if (k.includes(q)) includes.push(k);
      if (starts.length >= 8) break;
    }
    const results = starts.concat(includes).slice(0,8);
    if (results.length === 0){ suggBox.style.display = 'none'; return; }
    for (const r of results){
      const el = document.createElement('div');
      el.className = 'sugg';
      el.textContent = r;
      el.addEventListener('click', ()=> { input.value = r; suggBox.style.display = 'none'; input.focus(); });
      suggBox.appendChild(el);
    }
    suggBox.style.display = 'block';
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter'){
      e.preventDefault();
      submitGuess(input.value.trim());
    } else if (e.key === 'Escape'){
      suggBox.style.display = 'none';
    }
  });

  /* -------------------------
     Submit guess
     ------------------------- */
  function submitGuess(raw){
    if (!raw || !raw.trim()) { showHint("Type something to guess."); return; }
    const typedKey = raw.trim().toLowerCase();
    if (typedSet.has(typedKey)){ showHint(`You already guessed "${raw}".`); return; }

    let hex = lookupHexForInput(raw);
    if (!hex){
      // deterministic fallback (keeps guessable but not DB canonical)
      hex = hexFromName(raw.toLowerCase());
    }
    const normalizedHex = hexNormalize(hex);
    if (!normalizedHex){ showHint(`Couldn't parse "${raw}". Try #RRGGBB or a name.`); return; }
    if (normSet.has(normalizedHex)){ showHint(`That color (${normalizedHex}) was already guessed.`); return; }

    // record
    typedSet.add(typedKey);
    normSet.add(normalizedHex);
    totalGuesses++;
    updateStats();

    // compute perceptual similarity using Lab Î”E
    const userRgb = hexToRgb(normalizedHex);
    const userLab = rgbToLab(userRgb);
    const pct = deltaEPercent(userLab, secretLab);

    addGuessRow(raw, normalizedHex, pct);
    preview.style.background = normalizedHex;

    if (pct === 100){
      showHint(`ðŸŽ‰ Correct! ${lookupNameForHex(normalizedHex) || raw} (${normalizedHex}).`);
      revealSecret(normalizedHex);
    } else {
      showHint(`You're ${pct}% close.`);
    }

    input.value = '';
    suggBox.style.display = 'none';
  }

  /* -------------------------
     Reveal & refresh
     ------------------------- */
  function revealSecret(hex){
    const finalHex = hex || secretHex;
    const name = lookupNameForHex(finalHex) || secretName;
    secretSwatch.style.background = finalHex;
    secretNameEl.textContent = name || 'Unnamed';
    secretHexEl.textContent = finalHex;
  }

  giveBtn.addEventListener('click', () => {
    revealSecret();
    showHint('Secret revealed.');
  });

  refreshBtn.addEventListener('click', () => {
    securePickSecret();
    // reset history
    typedSet = new Set(); normSet = new Set(); totalGuesses = 0;
    guessList.innerHTML = '';
    updateStats();
    preview.style.background = '#000';
    showHint('New secret chosen â€” start guessing!');
  });

  /* -------------------------
     Initialize game
     ------------------------- */
  securePickSecret();
  updateStats();

  // Freeze internal helpers to make casual tampering harder
  Object.freeze(COLOR_DB);
  Object.freeze(lookupHexForInput);
  Object.freeze(lookupNameForHex);

  // intentionally do NOT attach secret or maps to window

})(); // end closure
</script>
</body>
</html>
