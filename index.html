<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bee Tower Defense Lite</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(to bottom, #fdf6e3, #ffe599);
    font-family: 'Fredoka One', cursive, sans-serif;
    user-select: none;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    margin: 16px 0 8px 0;
    color: #a06e00;
    text-shadow: 0 0 5px #d4af37;
  }
  #game-container {
    position: relative;
    background: #fff7d2;
    border: 3px solid #d4af37;
    border-radius: 10px;
    box-shadow: 0 0 15px #d4af37;
  }
  canvas {
    display: block;
    background: #fff7d2;
    border-radius: 10px;
  }
  #ui {
    margin-top: 8px;
    width: 800px;
    max-width: 90vw;
    display: flex;
    justify-content: space-around;
    color: #a06e00;
    font-size: 18px;
    text-shadow: 0 0 3px #d4af37;
  }
  #tower-info {
    margin-top: 12px;
    width: 800px;
    max-width: 90vw;
    display: flex;
    justify-content: center;
    gap: 20px;
  }
  .tower-button {
    background: #f7d560;
    border: 2px solid #a06e00;
    border-radius: 8px;
    cursor: pointer;
    padding: 10px 20px;
    box-shadow: 0 0 5px #d4af37;
    color: #5a3e00;
    font-weight: bold;
    transition: background 0.3s;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 120px;
  }
  .tower-button:hover {
    background: #ffe87c;
  }
  .tower-icon {
    font-size: 36px;
    margin-bottom: 6px;
  }
  #message {
    margin-top: 8px;
    font-size: 16px;
    color: #b33a00;
    height: 24px;
    min-height: 24px;
    font-weight: 700;
    text-align: center;
  }
</style>
</head>
<body>

<h1>Bee Tower Defense Lite üêù</h1>

<div id="game-container">
  <canvas id="gameCanvas" width="800" height="480" aria-label="Bee Tower Defense game area" role="img"></canvas>
</div>

<div id="ui" aria-live="polite" aria-atomic="true">
  <div>Money: <span id="money">100</span> üçØ</div>
  <div>Lives: <span id="lives">10</span> üêù</div>
  <div>Wave: <span id="wave">1</span></div>
</div>

<div id="tower-info">
  <button class="tower-button" id="basic-tower" aria-label="Place Basic Bee Tower for 50 honey">
    <div class="tower-icon">üêù</div>
    Basic Tower<br><small>Cost: 50 üçØ</small>
  </button>
  <button class="tower-button" id="slow-tower" aria-label="Place Slow-down Flower Tower for 70 honey">
    <div class="tower-icon">üå∏</div>
    Slow-down Tower<br><small>Cost: 70 üçØ</small>
  </button>
  <button class="tower-button" id="splash-tower" aria-label="Place Splash Hive Tower for 100 honey">
    <div class="tower-icon">üçØ</div>
    Splash Tower<br><small>Cost: 100 üçØ</small>
  </button>
</div>

<div id="message" role="alert" aria-live="assertive"></div>

<script>
(() => {
  // Setup canvas and context
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const moneyEl = document.getElementById('money');
  const livesEl = document.getElementById('lives');
  const waveEl = document.getElementById('wave');
  const messageEl = document.getElementById('message');

  // Game constants
  const TILE_SIZE = 40;
  const PATH = [
    {x:0, y:9}, {x:1, y:9}, {x:2, y:9}, {x:3, y:9}, {x:4, y:9},
    {x:5, y:9}, {x:6, y:9}, {x:7, y:9}, {x:8, y:9}, {x:9, y:9},
    {x:10, y:9}, {x:11, y:9}, {x:12, y:9}, {x:13, y:9}, {x:14, y:9},
    {x:15, y:9}, {x:16, y:9}, {x:17, y:9}, {x:18, y:9}, {x:19, y:9},
  ];
  const GRID_WIDTH = 20;
  const GRID_HEIGHT = 12;

  // Game variables
  let money = 100;
  let lives = 10;
  let wave = 1;
  let enemies = [];
  let towers = [];
  let placingTowerType = null;
  let gameOver = false;
  let lastEnemySpawn = 0;
  let enemySpawnInterval = 2000;
  let enemiesToSpawn = 5;
  let enemiesSpawned = 0;

  // Tower definitions
  const TOWERS = {
    basic: {
      cost: 50,
      range: 100,
      fireRate: 1000,
      damage: 10,
      icon: 'üêù',
      shootEffect: 'sting',
    },
    slow: {
      cost: 70,
      range: 80,
      fireRate: 1500,
      damage: 0,
      slowEffect: 0.5,
      slowDuration: 3000,
      icon: 'üå∏',
      shootEffect: 'pollen',
    },
    splash: {
      cost: 100,
      range: 80,
      fireRate: 2000,
      damage: 7,
      splashRadius: 60,
      icon: 'üçØ',
      shootEffect: 'hiveburst',
    }
  };

  // Enemy definitions
  const ENEMIES = {
    wasp: {
      maxHp: 30 + wave * 5,
      speed: 1 + wave * 0.1,
      reward: 10,
      color: '#b3522b',
      size: 24,
    },
    hornet: {
      maxHp: 50 + wave * 10,
      speed: 0.8 + wave * 0.05,
      reward: 20,
      color: '#7f2c1f',
      size: 28,
    }
  };

  // Utility functions
  function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  function gridToPixel(x, y) {
    return { px: x * TILE_SIZE, py: y * TILE_SIZE };
  }

  // Enemy class
  class Enemy {
    constructor(type) {
      this.type = type;
      this.maxHp = ENEMIES[type].maxHp;
      this.hp = this.maxHp;
      this.speed = ENEMIES[type].speed;
      this.reward = ENEMIES[type].reward;
      this.color = ENEMIES[type].color;
      this.size = ENEMIES[type].size;
      this.pathIndex = 0;
      const startPos = gridToPixel(PATH[0].x, PATH[0].y);
      this.x = startPos.px + TILE_SIZE/2;
      this.y = startPos.py + TILE_SIZE/2;
      this.slowedUntil = 0;
      this.isDead = false;
    }
    update(deltaTime, now) {
      if(this.isDead) return;
      let target = PATH[this.pathIndex + 1];
      if(!target) {
        // Reached end
        lives--;
        updateUI();
        this.isDead = true;
        checkGameOver();
        return;
      }
      const targetPos = gridToPixel(target.x, target.y);
      const targetX = targetPos.px + TILE_SIZE/2;
      const targetY = targetPos.py + TILE_SIZE/2;
      // Calculate speed (consider slow)
      let currentSpeed = this.speed;
      if(now < this.slowedUntil) currentSpeed *= 0.5;

      // Move towards target
      let dx = targetX - this.x;
      let dy = targetY - this.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < currentSpeed * deltaTime / 16) {
        // Arrived at next path point
        this.x = targetX;
        this.y = targetY;
        this.pathIndex++;
      } else {
        this.x += (dx / dist) * currentSpeed * deltaTime / 16;
        this.y += (dy / dist) * currentSpeed * deltaTime / 16;
      }
    }
    draw(ctx) {
      // Draw enemy body (circle)
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
      ctx.fill();
      // Draw enemy eyes
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(this.x - this.size/6, this.y - this.size/8, this.size/8, 0, Math.PI*2);
      ctx.arc(this.x + this.size/6, this.y - this.size/8, this.size/8, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(this.x - this.size/6, this.y - this.size/8, this.size/16, 0, Math.PI*2);
      ctx.arc(this.x + this.size/6, this.y - this.size/8, this.size/16, 0, Math.PI*2);
      ctx.fill();

      // Draw health bar above enemy
      const barWidth = this.size;
      const barHeight = 6;
      const hpRatio = this.hp / this.maxHp;
      ctx.fillStyle = 'red';
      ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 12, barWidth, barHeight);
      ctx.fillStyle = 'limegreen';
      ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 12, barWidth * hpRatio, barHeight);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(this.x - barWidth/2, this.y - this.size/2 - 12, barWidth, barHeight);
    }
  }

  // Tower class
  class Tower {
    constructor(type, gridX, gridY) {
      this.type = type;
      this.gridX = gridX;
      this.gridY = gridY;
      this.range = TOWERS[type].range;
      this.fireRate = TOWERS[type].fireRate;
      this.damage = TOWERS[type].damage || 0;
      this.slowEffect = TOWERS[type].slowEffect || 0;
      this.slowDuration = TOWERS[type].slowDuration || 0;
      this.splashRadius = TOWERS[type].splashRadius || 0;
      this.icon = TOWERS[type].icon;
      this.shootEffect = TOWERS[type].shootEffect;
      this.lastShot = 0;
    }
    draw(ctx) {
      const {px, py} = gridToPixel(this.gridX, this.gridY);
      // Draw tower base circle
      ctx.fillStyle = '#f7d560';
      ctx.strokeStyle = '#a06e00';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/2 - 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // Draw icon (emoji)
      ctx.font = '28px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#a06e00';
      ctx.fillText(this.icon, px + TILE_SIZE/2, py + TILE_SIZE/2);
      // Draw range circle (semi-transparent)
      ctx.strokeStyle = 'rgba(160, 110, 0, 0.25)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, this.range, 0, Math.PI*2);
      ctx.stroke();
    }
    update(now, deltaTime) {
      if(now - this.lastShot < this.fireRate) return;
      // Find first enemy in range
      let target = null;
      for(let enemy of enemies) {
        if(enemy.isDead) continue;
        const dist = distance(enemy, {
          x: this.gridX * TILE_SIZE + TILE_SIZE/2,
          y: this.gridY * TILE_SIZE + TILE_SIZE/2,
        });
        if(dist <= this.range) {
          target = enemy;
          break;
        }
      }
      if(target) {
        this.shoot(target);
        this.lastShot = now;
      }
    }
    shoot(enemy) {
      if(this.type === 'basic') {
        enemy.hp -= this.damage;
        if(enemy.hp <= 0) {
          enemy.isDead = true;
          money += enemy.reward;
          updateUI();
          showMessage(`Enemy defeated! +${enemy.reward} üçØ`);
        }
      }
      else if(this.type === 'slow') {
        enemy.slowedUntil = performance.now() + this.slowDuration;
        showMessage('Enemy slowed!');
      }
      else if(this.type === 'splash') {
        // Damage all enemies within splash radius
        for(let e of enemies) {
          if(e.isDead) continue;
          if(distance(enemy, e) <= this.splashRadius) {
            e.hp -= this.damage;
            if(e.hp <= 0) {
              e.isDead = true;
              money += e.reward;
              updateUI();
              showMessage(`Enemy defeated! +${e.reward} üçØ`);
            }
          }
        }
      }
    }
  }

  // Game logic
  function updateUI() {
    moneyEl.textContent = money;
    livesEl.textContent = lives;
    waveEl.textContent = wave;
  }

  function showMessage(text) {
    messageEl.textContent = text;
    clearTimeout(messageEl._timeout);
    messageEl._timeout = setTimeout(() => {
      if(messageEl.textContent === text) messageEl.textContent = '';
    }, 2500);
  }

  function checkGameOver() {
    if(lives <= 0) {
      gameOver = true;
      showMessage('Game Over! Refresh to play again.');
    }
  }

  // Draw grid and path
  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw grid squares (light yellow)
    ctx.fillStyle = '#fff4c1';
    for(let y=0; y<GRID_HEIGHT; y++) {
      for(let x=0; x<GRID_WIDTH; x++) {
        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
      }
    }

    // Draw path tiles (darker yellow)
    ctx.fillStyle = '#f9d56e';
    for(let p of PATH) {
      ctx.fillRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
    }
  }

  // Draw hive at end of path
  function drawHive() {
    const last = PATH[PATH.length - 1];
    const {px, py} = gridToPixel(last.x, last.y);
    ctx.fillStyle = '#d4af37';
    ctx.strokeStyle = '#a06e00';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(px + TILE_SIZE/2, py + 6);
    ctx.lineTo(px + TILE_SIZE - 10, py + TILE_SIZE/2);
    ctx.lineTo(px + TILE_SIZE/2, py + TILE_SIZE - 6);
    ctx.lineTo(px + 10, py + TILE_SIZE/2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // Game loop variables
  let lastTime = 0;

  function gameLoop(timestamp = 0) {
    if(gameOver) return;

    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    // Spawn enemies
    if(enemiesSpawned < enemiesToSpawn && timestamp - lastEnemySpawn > enemySpawnInterval) {
      spawnEnemy();
      lastEnemySpawn = timestamp;
    }

    // Update enemies
    for(let enemy of enemies) {
      enemy.update(deltaTime, timestamp);
    }
    // Remove dead enemies
    enemies = enemies.filter(e => !e.isDead);

    // Update towers
    for(let tower of towers) {
      tower.update(timestamp, deltaTime);
    }

    // Draw everything
    drawGrid();
    drawHive();
    for(let tower of towers) {
      tower.draw(ctx);
    }
    for(let enemy of enemies) {
      enemy.draw(ctx);
    }

    // Check wave complete
    if(enemies.length === 0 && enemiesSpawned === enemiesToSpawn) {
      wave++;
      waveEl.textContent = wave;
      enemiesToSpawn += 2;
      enemiesSpawned = 0;
      enemySpawnInterval = Math.max(500, enemySpawnInterval - 100);
      money += 50;
      updateUI();
      showMessage(`Wave ${wave} starting!`);
    }

    requestAnimationFrame(gameLoop);
  }

  // Spawn enemy
  function spawnEnemy() {
    // Alternate enemy types by wave
    let type = wave % 2 === 0 ? 'wasp' : 'hornet';
    let enemy = new Enemy(type);
    enemies.push(enemy);
    enemiesSpawned++;
  }

  // Handle placing towers on click
  canvas.addEventListener('click', e => {
    if(gameOver) return;
    if(!placingTowerType) {
      showMessage('Select a tower first!');
      return;
    }
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    const gridX = Math.floor(clickX / TILE_SIZE);
    const gridY = Math.floor(clickY / TILE_SIZE);

    // Prevent placing on path
    if(PATH.some(p => p.x === gridX && p.y === gridY)) {
      showMessage('Cannot place tower on path!');
      return;
    }
    // Prevent placing outside grid
    if(gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT) {
      showMessage('Invalid position!');
      return;
    }
    // Prevent placing tower on existing tower
    if(towers.some(t => t.gridX === gridX && t.gridY === gridY)) {
      showMessage('Tower already here!');
      return;
    }
    // Check money
    if(money < TOWERS[placingTowerType].cost) {
      showMessage('Not enough honey!');
      return;
    }

    // Place tower
    money -= TOWERS[placingTowerType].cost;
    updateUI();
    towers.push(new Tower(placingTowerType, gridX, gridY));
    showMessage(`${placingTowerType.charAt(0).toUpperCase() + placingTowerType.slice(1)} Tower placed!`);
  });

  // Tower button events
  document.getElementById('basic-tower').addEventListener('click', () => {
    placingTowerType = 'basic';
    showMessage('Selected Basic Bee Tower');
  });
  document.getElementById('slow-tower').addEventListener('click', () => {
    placingTowerType = 'slow';
    showMessage('Selected Slow-down Flower Tower');
  });
  document.getElementById('splash-tower').addEventListener('click', () => {
    placingTowerType = 'splash';
    showMessage('Selected Splash Hive Tower');
  });

  // Initial UI update and start game loop
  updateUI();
  showMessage('Select a tower to place!');
  gameLoop();
})();
</script>

</body>
</html>
