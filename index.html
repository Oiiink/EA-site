<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dating Sim with Relationship Meter & Minigame</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #f9f6f2, #c6d8d3);
    margin: 0; padding: 20px; color: #333;
  }
  #game {
    max-width: 640px;
    margin: auto;
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
  #portrait {
    width: 140px;
    height: 140px;
    margin: 0 auto 15px;
    border-radius: 50%;
    overflow: hidden;
    box-shadow: 0 0 15px #7b9aa7;
  }
  #portrait img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #charName {
    text-align: center;
    font-size: 1.8em;
    font-weight: 700;
    margin-bottom: 8px;
    color: #3a5a40;
  }
  #relationshipBar {
    width: 100%;
    height: 24px;
    background: #ddd;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 10px;
  }
  #relationshipFill {
    height: 100%;
    width: 0%;
    background: #56ab2f;
    transition: width 0.5s ease;
  }
  #mood {
    text-align: center;
    font-style: italic;
    margin-bottom: 15px;
    font-weight: 600;
    color: #427839;
  }
  #dialogue {
    min-height: 100px;
    font-size: 1.2em;
    line-height: 1.4;
    margin-bottom: 15px;
    padding: 10px;
    background: #f0f4f3;
    border-radius: 8px;
  }
  #choices {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  button.choice {
    background: #3a5a40;
    color: #fff;
    border: none;
    padding: 12px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: background-color 0.3s ease;
  }
  button.choice:hover {
    background-color: #2e4a33;
  }
  #minigame {
    margin-top: 20px;
    padding: 15px;
    background: #e6f0ec;
    border-radius: 10px;
    display: none;
    text-align: center;
  }
  #minigame button {
    background: #5a8267;
    color: #fff;
    padding: 10px 15px;
    border: none;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    margin-top: 10px;
  }
</style>
</head>
<body>
<div id="game">
  <div id="portrait"><img src="" alt="Character Portrait" /></div>
  <div id="charName"></div>

  <div id="relationshipBar">
    <div id="relationshipFill"></div>
  </div>
  <div id="mood"></div>
  <div id="dialogue"></div>
  <div id="choices"></div>

  <div id="minigame">
    <div id="minigameText"></div>
    <button id="playMinigameBtn">Play Minigame</button>
  </div>
</div>

<script>
(() => {
  // Character definition with personality traits, likes, dislikes
  const character = {
    name: "Sakura",
    avatarUrl: "https://avatars.dicebear.com/api/female/sakura.svg",
    moodLevels: ["Annoyed", "Neutral", "Happy", "Excited"],
    mood: 1, // starts Neutral
    relationship: 30, // out of 100
    interests: ["reading", "chocolate", "gardening"],
    dislikes: ["rudeness", "lateness"],
    memory: { // Track answers or events
      askedAboutHobbies: 0,
      gaveCompliment: 0,
      minigamePlayed: false,
    }
  };

  const portrait = document.querySelector("#portrait img");
  const charName = document.getElementById("charName");
  const relationshipFill = document.getElementById("relationshipFill");
  const moodEl = document.getElementById("mood");
  const dialogueEl = document.getElementById("dialogue");
  const choicesEl = document.getElementById("choices");
  const minigameEl = document.getElementById("minigame");
  const minigameText = document.getElementById("minigameText");
  const playMinigameBtn = document.getElementById("playMinigameBtn");

  // Dialogue nodes with conditions and effects on mood/relationship
  const dialogueTree = {
    start: {
      text: "Hi there! What do you want to talk about?",
      choices: [
        { text: "Ask about hobbies", next: "hobbies" },
        { text: "Give a compliment", next: "compliment" },
        { text: "Play a minigame", next: "startMinigame" },
        { text: "Say goodbye", next: "goodbye" },
      ]
    },
    hobbies: {
      text: () => {
        character.memory.askedAboutHobbies++;
        if(character.memory.askedAboutHobbies === 1) {
          adjustRelationship(5);
          adjustMood(1);
          return "I love reading books, especially fantasy. I also enjoy gardening and chocolate!";
        } else if(character.memory.askedAboutHobbies === 2) {
          adjustRelationship(2);
          adjustMood(0);
          return "I've already told you, I like reading, gardening, and chocolate.";
        } else {
          adjustRelationship(-2);
          adjustMood(-1);
          return "You keep asking the same thing, it's getting annoying...";
        }
      },
      choices: [
        { text: "Sounds interesting!", next: "start" },
        { text: "Not really my thing", next: "dislikeHobbies" },
      ]
    },
    dislikeHobbies: {
      text: () => {
        adjustRelationship(-5);
        adjustMood(-1);
        return "Oh, that's disappointing to hear...";
      },
      choices: [
        { text: "Sorry, let's talk about something else", next: "start" }
      ]
    },
    compliment: {
      text: () => {
        character.memory.gaveCompliment++;
        if(character.memory.gaveCompliment === 1) {
          adjustRelationship(10);
          adjustMood(2);
          return "Aww, thank you! That means a lot to me.";
        } else if(character.memory.gaveCompliment === 2) {
          adjustRelationship(5);
          adjustMood(1);
          return "You're so sweet!";
        } else {
          adjustRelationship(-5);
          adjustMood(-2);
          return "You're flattering me a bit too much...";
        }
      },
      choices: [
        { text: "I mean it!", next: "start" },
        { text: "Back", next: "start" }
      ]
    },
    startMinigame: {
      text: () => "Let's play a quick minigame! Try to click the button when the timer hits zero.",
      choices: [],
      action: "startMinigame"
    },
    minigameResultWin: {
      text: () => {
        adjustRelationship(15);
        adjustMood(3);
        character.memory.minigamePlayed = true;
        return "Wow! You did great! I had so much fun playing with you.";
      },
      choices: [
        { text: "Thanks!", next: "start" }
      ]
    },
    minigameResultLose: {
      text: () => {
        adjustRelationship(-5);
        adjustMood(-1);
        character.memory.minigamePlayed = true;
        return "Oh, so close! Better luck next time!";
      },
      choices: [
        { text: "I'll try again", next: "start" }
      ]
    },
    goodbye: {
      text: "Bye! Hope to talk to you again soon.",
      choices: []
    }
  };

  function adjustRelationship(amount) {
    character.relationship = Math.min(100, Math.max(0, character.relationship + amount));
    updateRelationshipBar();
  }

  function adjustMood(amount) {
    character.mood = Math.min(character.moodLevels.length - 1, Math.max(0, character.mood + amount));
    updateMood();
  }

  function updateRelationshipBar() {
    relationshipFill.style.width = character.relationship + "%";
    // Color gradient from red (0) to green (100)
    const green = Math.floor((character.relationship / 100) * 170 + 50);
    const red = 220 - green;
    relationshipFill.style.backgroundColor = `rgb(${red},${green},70)`;
  }

  function updateMood() {
    moodEl.textContent = `Mood: ${character.moodLevels[character.mood]}`;
    const moodsColors = ["#aa4444", "#999999", "#4caf50", "#a3d977"];
    moodEl.style.color = moodsColors[character.mood] || "#333";
  }

  function setDialogue(text) {
    dialogueEl.textContent = (typeof text === "function") ? text() : text;
  }

  function renderChoices(choices) {
    choicesEl.innerHTML = "";
    if(choices.length === 0) {
      // Show restart button
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.textContent = "Restart";
      btn.onclick = () => {
        currentNode = "start";
        renderNode(currentNode);
      };
      choicesEl.appendChild(btn);
      return;
    }
    choices.forEach(choice => {
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.textContent = choice.text;
      btn.onclick = () => {
        if(choice.next) {
          currentNode = choice.next;
          renderNode(currentNode);
        }
      };
      choicesEl.appendChild(btn);
    });
  }

  let currentNode = "start";

  function renderNode(nodeKey) {
    const node = dialogueTree[nodeKey];
    if(!node) return;

    // Show avatar & name
    portrait.src = character.avatarUrl;
    charName.textContent = character.name;

    // Run any action attached to node
    if(node.action === "startMinigame") {
      showMinigame();
    } else {
      hideMinigame();
    }

    setDialogue(node.text);
    renderChoices(node.choices);

    updateMood();
    updateRelationshipBar();
  }

  // --- Minigame: Reaction test ---

  const minigameButton = document.createElement("button");
  minigameButton.textContent = "Click me!";
  minigameButton.style.padding = "15px 25px";
  minigameButton.style.fontSize = "1.2em";
  minigameButton.style.cursor = "pointer";

  let timerId = null;
  let waitingForClick = false;

  function showMinigame() {
    minigameEl.style.display = "block";
    minigameText.textContent = "Wait for the button to turn green, then click it as fast as you can!";
    minigameEl.appendChild(minigameButton);
    minigameButton.disabled = true;
    minigameButton.style.backgroundColor = "#777";
    waitingForClick = false;

    // Random wait between 1.5s and 3.5s
    const waitTime = 1500 + Math.random() * 2000;
    timerId = setTimeout(() => {
      minigameButton.style.backgroundColor = "#4caf50";
      minigameButton.disabled = false;
      waitingForClick = true;
      // Start reaction timer (max 1.5s to click)
      const startTime = Date.now();
      minigameButton.onclick = () => {
        if(!waitingForClick) return;
        waitingForClick = false;
        const reactionTime = Date.now() - startTime;
        if(reactionTime <= 1500) {
          currentNode = "minigameResultWin";
        } else {
          currentNode = "minigameResultLose";
        }
        renderNode(currentNode);
      };
    }, waitTime);

    // If user clicks early
    minigameButton.onclick = () => {
      if(waitingForClick) return;
      // Clicked too early
      clearTimeout(timerId);
      currentNode = "minigameResultLose";
      renderNode(currentNode);
    };
  }

  function hideMinigame() {
    minigameEl.style.display = "none";
    minigameButton.onclick = null;
    clearTimeout(timerId);
  }

  // Start game
  renderNode(currentNode);
})();
</script>
</body>
</html>
