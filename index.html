<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Glass Bridge Mini Game</title>
<style>
  body, html {
    margin: 0; padding: 0; background: #111;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100vh; color: #eee; font-family: Arial, sans-serif;
    user-select: none;
  }
  canvas {
    border: 3px solid #eee;
    background: #222;
    display: block;
  }
  #info {
    margin: 10px;
    font-size: 18px;
    text-align: center;
  }
  #message {
    margin-top: 15px;
    font-size: 24px;
    font-weight: bold;
    color: #f33;
  }
  #restart {
    margin-top: 10px;
    padding: 8px 16px;
    font-size: 16px;
    background: #f3da0b;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    color: #111;
  }
  #restart:hover {
    background: #c9b008;
  }
</style>
</head>
<body>

<div id="info">Use arrow keys or WASD to move forward and sideways. Reach the end without falling!</div>
<canvas id="game" width="600" height="600"></canvas>
<div id="message"></div>
<button id="restart" style="display:none;">Restart Game</button>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const ROWS = 10;     // Number of rows in the bridge (depth)
  const COLS = 6;      // Number of tiles across (width)
  const TILE_SIZE = 50;

  // Tiles: true = strong tile, false = weak tile (breaks)
  let bridge = [];

  // Player position: row and col (row 0 is start, row ROWS-1 is finish)
  let player = { row: 0, col: Math.floor(COLS/2) };

  // Game state
  let gameOver = false;
  let messageEl = document.getElementById('message');
  let restartBtn = document.getElementById('restart');
  let attempts = 0;

  // Generate the bridge pattern
  function generateBridge() {
    bridge = [];
    for(let r=0; r<ROWS; r++) {
      let row = [];
      for(let c=0; c<COLS; c++) {
        // Randomly assign strong/weak tile: about 40% weak
        row.push(Math.random() < 0.6);
      }
      bridge.push(row);
    }
    // Ensure start and finish rows are all strong tiles
    for(let c=0; c<COLS; c++) {
      bridge[0][c] = true;
      bridge[ROWS-1][c] = true;
    }
  }

  // Draw the bridge tiles and player
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();

    // Draw tiles
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const x = c * TILE_SIZE + (canvas.width - COLS*TILE_SIZE)/2;
        const y = r * TILE_SIZE + 50;

        // Tile color depends on tile type and if broken
        if(bridge[r][c] === null) {
          // Broken tile
          ctx.fillStyle = '#222';
          ctx.strokeStyle = '#660000';
          ctx.lineWidth = 3;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
          ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);

          // Cracks lines
          ctx.strokeStyle = '#aa0000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + 5, y + 5);
          ctx.lineTo(x + TILE_SIZE - 5, y + TILE_SIZE - 5);
          ctx.moveTo(x + TILE_SIZE - 5, y + 5);
          ctx.lineTo(x + 5, y + TILE_SIZE - 5);
          ctx.stroke();

        } else if (bridge[r][c]) {
          // Strong tile - teal-ish
          ctx.fillStyle = '#1e7f7f';
          ctx.strokeStyle = '#145454';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
          ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        } else {
          // Weak tile - grayish
          ctx.fillStyle = '#555';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
          ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    // Draw player (red square)
    const px = player.col * TILE_SIZE + (canvas.width - COLS*TILE_SIZE)/2;
    const py = player.row * TILE_SIZE + 50;
    ctx.fillStyle = '#f33';
    ctx.shadowColor = '#f33';
    ctx.shadowBlur = 15;
    ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10);

    ctx.restore();

    // Draw progress bar background
    const barX = (canvas.width - 300)/2;
    const barY = 20;
    const barWidth = 300;
    const barHeight = 15;
    ctx.fillStyle = '#333';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    // Progress fill
    ctx.fillStyle = '#f3da0b';
    const progress = player.row / (ROWS - 1);
    ctx.fillRect(barX, barY, progress * barWidth, barHeight);

    // Progress text
    ctx.fillStyle = '#eee';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Progress: ${(progress*100).toFixed(0)}%`, canvas.width/2, barY + barHeight - 2);
  }

  // Handle player move if allowed
  function movePlayer(dr, dc) {
    if(gameOver) return;

    const newRow = player.row + dr;
    const newCol = player.col + dc;

    if(newRow < 0 || newRow >= ROWS) return;
    if(newCol < 0 || newCol >= COLS) return;

    player.row = newRow;
    player.col = newCol;

    // Check tile stability
    const tile = bridge[newRow][newCol];
    if(tile === false) {
      // weak tile - break and lose
      bridge[newRow][newCol] = null; // mark broken
      gameOver = true;
      messageEl.textContent = 'You fell through a weak tile! Game Over.';
      restartBtn.style.display = 'inline-block';
      attempts++;
      return;
    }

    if(newRow === ROWS - 1) {
      // Reached the end - win
      gameOver = true;
      messageEl.textContent = `You crossed safely! Attempts: ${attempts + 1}`;
      restartBtn.style.display = 'inline-block';
      attempts++;
      return;
    }
  }

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if(gameOver) return;
    switch(e.key) {
      case 'ArrowUp':
      case 'w':
      case 'W':
        movePlayer(-1, 0);
        break;
      case 'ArrowDown':
      case 's':
      case 'S':
        movePlayer(1, 0);
        break;
      case 'ArrowLeft':
      case 'a':
      case 'A':
        movePlayer(0, -1);
        break;
      case 'ArrowRight':
      case 'd':
      case 'D':
        movePlayer(0, 1);
        break;
    }
    draw();
  });

  // Restart game
  restartBtn.addEventListener('click', () => {
    gameOver = false;
    messageEl.textContent = '';
    restartBtn.style.display = 'none';
    player = { row: 0, col: Math.floor(COLS/2) };
    generateBridge();
    draw();
  });

  // Initial setup
  generateBridge();
  draw();

})();
</script>

</body>
</html>
