(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // UI Elements
  const baseHealthDisplay = document.getElementById('base-health');
  const moneyDisplay = document.getElementById('money');
  const waveInfoDisplay = document.getElementById('wave-info');
  const towerInfoDiv = document.getElementById('tower-details');
  const upgradeButtonsDiv = document.getElementById('upgrade-buttons');
  const messageDiv = document.getElementById('message');
  const towerOptions = document.querySelectorAll('.tower-option');
  const tooltip = document.getElementById('tooltip');

  // Game constants
  const TILE_SIZE = 50;
  const MAP_ROWS = 10;
  const MAP_COLS = 18;
  const BASE_HEALTH_START = 10;
  const INITIAL_MONEY = 100;

  // Path for enemies (simple zig-zag)
  const path = [
    { x: 0, y: 4 },
    { x: 8, y: 4 },
    { x: 8, y: 7 },
    { x: 17, y: 7 }
  ];

  // Obstacles (blocked tiles)
  const obstacles = [
    { x: 4, y: 2 },
    { x: 5, y: 2 },
    { x: 12, y: 5 },
    { x: 13, y: 5 },
    { x: 10, y: 1 },
    { x: 11, y: 1 },
  ];

  // Tower types with stats and upgrade info
  const towerTypes = {
    basic: {
      name: "Basic Tower",
      baseCost: 50,
      range: 120,
      damage: 10,
      fireRate: 1000, // ms cooldown
      upgrades: [
        { cost: 40, damage: 15, range: 140, fireRate: 900 },
        { cost: 80, damage: 20, range: 160, fireRate: 800 },
        { cost: 120, damage: 25, range: 180, fireRate: 700 }
      ]
    },
    rapid: {
      name: "Rapid Fire",
      baseCost: 80,
      range: 110,
      damage: 6,
      fireRate: 400,
      upgrades: [
        { cost: 50, damage: 8, range: 120, fireRate: 350 },
        { cost: 90, damage: 10, range: 130, fireRate: 300 },
        { cost: 130, damage: 12, range: 150, fireRate: 250 }
      ]
    },
    slow: {
      name: "Slowdown",
      baseCost: 70,
      range: 130,
      damage: 4,
      fireRate: 1500,
      upgrades: [
        { cost: 60, damage: 6, range: 140, fireRate: 1300 },
        { cost: 100, damage: 8, range: 150, fireRate: 1100 },
        { cost: 150, damage: 10, range: 160, fireRate: 1000 }
      ],
      slowEffect: 0.5,
      slowDuration: 2000
    }
  };

  // Enemy types
  const enemyTypes = {
    scout: {
      name: "Bee Scout",
      maxHealth: 30,
      speed: 1.8,
      reward: 8,
      color: "#ffdd57"
    },
    tank: {
      name: "Bee Tank",
      maxHealth: 120,
      speed: 0.8,
      reward: 20,
      color: "#b88723"
    },
    bomber: {
      name: "Bee Bomber",
      maxHealth: 50,
      speed: 1.3,
      reward: 15,
      color: "#de354c"
    },
    worker: {
      name: "Bee Worker",
      maxHealth: 70,
      speed: 1.2,
      reward: 12,
      color: "#34a853"
    }
  };

  // Game state
  let baseHealth = BASE_HEALTH_START;
  let money = INITIAL_MONEY;
  let waveNumber = 0;
  let enemies = [];
  let towers = [];
  let projectiles = [];
  let selectedTowerType = null;
  let selectedTower = null;
  let placingTower = false;
  let gameOver = false;
  let lastEnemySpawn = 0;
  let enemiesToSpawn = 0;
  let enemySpawnInterval = 1000;
  let lastFrameTime = 0;

  // Tower placement grid, to check for blocking
  let towerGrid = new Array(MAP_ROWS).fill(null).map(() => new Array(MAP_COLS).fill(false));

  // Helper functions
  function pointDistance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
  }

  // Tooltip handling for tower options
  towerOptions.forEach(option => {
    option.addEventListener('mouseenter', e => {
      const type = e.currentTarget.dataset.type;
      const ttText = generateTowerTooltip(type);
      tooltip.textContent = ttText;
      const rect = e.currentTarget.getBoundingClientRect();
      tooltip.style.left = rect.left + rect.width/2 + 'px';
      tooltip.style.top = rect.top - 35 + 'px';
      tooltip.style.opacity = '1';
    });
    option.addEventListener('mouseleave', () => {
      tooltip.style.opacity = '0';
    });

    option.addEventListener('click', e => {
      if(gameOver) return;
      towerOptions.forEach(opt => opt.classList.remove('selected'));
      e.currentTarget.classList.add('selected');
      selectedTowerType = e.currentTarget.dataset.type;
      selectedTower = null;
      updateTowerInfo(null);
      placingTower = true;
      messageDiv.textContent = "Click on the map to place your " + towerTypes[selectedTowerType].name;
    });
  });

  function generateTowerTooltip(type) {
    const t = towerTypes[type];
    return `${t.name}\nDamage: ${t.damage}\nRange: ${t.range}\nFire Rate: ${(t.fireRate/1000).toFixed(2)}s\nCost: $${t.baseCost}`;
  }

  // Tower info UI update
  function updateTowerInfo(tower) {
    if(!tower) {
      towerInfoDiv.textContent = 'Select a tower to see details';
      upgradeButtonsDiv.innerHTML = '';
      return;
    }
    const typeData = towerTypes[tower.type];
    let html = `
      <p><strong>${typeData.name}</strong> (Level ${tower.level + 1})</p>
      <p>Damage: ${tower.damage}</p>
      <p>Range: ${tower.range}</p>
      <p>Fire Rate: ${(tower.fireRate/1000).toFixed(2)}s</p>
    `;
    upgradeButtonsDiv.innerHTML = '';
    const nextUpgrade = typeData.upgrades[tower.level];
    if(nextUpgrade) {
      const btn = document.createElement('button');
      btn.className = 'upgrade-btn';
      btn.textContent = `Upgrade ($${nextUpgrade.cost})`;
      btn.disabled = money < nextUpgrade.cost;
      btn.onclick = () => {
        if(money >= nextUpgrade.cost) {
          money -= nextUpgrade.cost;
          tower.level++;
          tower.damage = nextUpgrade.damage;
          tower.range = nextUpgrade.range;
          tower.fireRate = nextUpgrade.fireRate;
          updateTowerInfo(tower);
          messageDiv.textContent = `${typeData.name} upgraded!`;
          updateUI();
        } else {
          messageDiv.textContent = 'Not enough money to upgrade!';
        }
      };
      upgradeButtonsDiv.appendChild(btn);
    } else {
      upgradeButtonsDiv.textContent = 'Max level reached.';
    }
    towerInfoDiv.innerHTML = html;
  }

  // Check if tower can be placed on given tile (not obstacle, no tower, not path)
  function canPlaceTower(col, row) {
    if(col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return false;
    if(towerGrid[row][col]) return false;
    if(obstacles.some(o => o.x === col && o.y === row)) return false;
    // Check if tile is on path (enemies walk center of tiles)
    for(let i=0; i<path.length-1; i++) {
      const start = path[i];
      const end = path[i+1];
      if(isPointOnSegment(col + 0.5, row + 0.5, start.x, start.y, end.x, end.y)) return false;
    }
    return true;
  }

  // Check if point is on line segment (for path)
  function isPointOnSegment(px, py, x1, y1, x2, y2) {
    const cross = Math.abs((py - y1)*(x2 - x1) - (px - x1)*(y2 - y1));
    if(cross > 0.2) return false;
    const dot = (px - x1)*(x2 - x1) + (py - y1)*(y2 - y1);
    if(dot < 0) return false;
    const lenSq = (x2 - x1)**2 + (y2 - y1)**2;
    if(dot > lenSq) return false;
    return true;
  }

  // Place tower on tile if allowed
  canvas.addEventListener('click', e => {
    if(!placingTower || gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const col = Math.floor((e.clientX - rect.left) / TILE_SIZE);
    const row = Math.floor((e.clientY - rect.top) / TILE_SIZE);
    if(canPlaceTower(col, row)) {
      if(money >= towerTypes[selectedTowerType].baseCost) {
        towers.push({
          type: selectedTowerType,
          x: col * TILE_SIZE + TILE_SIZE/2,
          y: row * TILE_SIZE + TILE_SIZE/2,
          damage: towerTypes[selectedTowerType].damage,
          range: towerTypes[selectedTowerType].range,
          fireRate: towerTypes[selectedTowerType].fireRate,
          level: 0,
          lastShot: 0,
          slowEffect: towerTypes[selectedTowerType].slowEffect || 0,
          slowDuration: towerTypes[selectedTowerType].slowDuration || 0,
          target: null
        });
        money -= towerTypes[selectedTowerType].baseCost;
        towerGrid[row][col] = true;
        messageDiv.textContent = `${towerTypes[selectedTowerType].name} placed!`;
        updateUI();
        placingTower = false;
        selectedTowerType = null;
        towerOptions.forEach(opt => opt.classList.remove('selected'));
      } else {
        messageDiv.textContent = 'Not enough money to place tower!';
      }
    } else {
      messageDiv.textContent = 'Cannot place tower here!';
    }
  });

  // Select tower on click to upgrade
  canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if(gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    selectedTower = null;
    for(let t of towers) {
      if(pointDistance(mouseX, mouseY, t.x, t.y) < TILE_SIZE/2) {
        selectedTower = t;
        updateTowerInfo(t);
        messageDiv.textContent = `Selected ${towerTypes[t.type].name} for upgrade`;
        break;
      }
    }
  });

  // Spawn waves
  function spawnWave() {
    waveNumber++;
    waveInfoDisplay.textContent = `Wave: ${waveNumber}`;
    enemiesToSpawn = 8 + waveNumber * 2;
    lastEnemySpawn = 0;
  }

  // Generate enemy randomly by wave (scaled difficulty)
  function getRandomEnemyType() {
    const roll = Math.random();
    if (roll < 0.35) return 'scout';
    else if (roll < 0.6) return 'worker';
    else if (roll < 0.85) return 'bomber';
    else return 'tank';
  }

  // Enemy class
  class Enemy {
    constructor(type) {
      this.type = type;
      const data = enemyTypes[type];
      this.x = path[0].x * TILE_SIZE + TILE_SIZE/2;
      this.y = path[0].y * TILE_SIZE + TILE_SIZE/2;
      this.speed = data.speed;
      this.maxHealth = data.maxHealth;
      this.health = this.maxHealth;
      this.reward = data.reward;
      this.color = data.color;
      this.currentPathIndex = 0;
      this.slowedUntil = 0;
    }

    update(dt, now) {
      // If slowed
      let currentSpeed = this.speed;
      if(now < this.slowedUntil) currentSpeed *= 0.5;

      // Move towards next path point
      const target = path[this.currentPathIndex + 1];
      if(!target) return false; // reached end

      const targetX = target.x * TILE_SIZE + TILE_SIZE/2;
      const targetY = target.y * TILE_SIZE + TILE_SIZE/2;
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const dist = Math.hypot(dx, dy);
      if(dist < currentSpeed * dt) {
        this.x = targetX;
        this.y = targetY;
        this.currentPathIndex++;
        if(this.currentPathIndex >= path.length - 1) {
          return true; // reached base
        }
      } else {
        this.x += (dx / dist) * currentSpeed * dt;
        this.y += (dy / dist) * currentSpeed * dt;
      }
      return false;
    }

    draw(ctx) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(this.x, this.y, 16, 12, 0, 0, Math.PI*2);
      ctx.fill();

      // Health bar
      const healthBarWidth = 30;
      const healthBarHeight = 5;
      const healthPercent = this.health / this.maxHealth;
      ctx.fillStyle = 'black';
      ctx.fillRect(this.x - healthBarWidth/2, this.y - 22, healthBarWidth, healthBarHeight);
      ctx.fillStyle = '#2ecc71';
      ctx.fillRect(this.x - healthBarWidth/2, this.y - 22, healthBarWidth * healthPercent, healthBarHeight);
    }
  }

  // Projectile class
  class Projectile {
    constructor(x, y, target, damage, slowEffect = 0, slowDuration = 0) {
      this.x = x;
      this.y = y;
      this.target = target;
      this.speed = 400;
      this.damage = damage;
      this.radius = 5;
      this.slowEffect = slowEffect;
      this.slowDuration = slowDuration;
      this.active = true;
    }

    update(dt) {
      if(!this.active || !this.target) return false;

      const dx = this.target.x - this.x;
      const dy = this.target.y - this.y;
      const dist = Math.hypot(dx, dy);
      if(dist < this.speed * dt) {
        // Hit target
        this.target.health -= this.damage;
        if(this.slowEffect > 0) {
          this.target.slowedUntil = Date.now() + this.slowDuration;
        }
        this.active = false;
        return true;
      } else {
        this.x += (dx / dist) * this.speed * dt;
        this.y += (dy / dist) * this.speed * dt;
        return false;
      }
    }

    draw(ctx) {
      if(!this.active) return;
      ctx.fillStyle = this.slowEffect > 0 ? '#3498db' : '#f1c40f';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Update UI
  function updateUI() {
    baseHealthDisplay.textContent = `Base Health: ${baseHealth}`;
    moneyDisplay.textContent = `Money: ${money}`;
    waveInfoDisplay.textContent = `Wave: ${waveNumber}`;
  }

  // Draw grid, obstacles, path
  function drawMap() {
    // Grid
    ctx.strokeStyle = '#b0d6a5';
    for(let r=0; r<MAP_ROWS; r++) {
      for(let c=0; c<MAP_COLS; c++) {
        ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      }
    }

    // Obstacles
    obstacles.forEach(o => {
      ctx.fillStyle = '#7c6651';
      ctx.fillRect(o.x * TILE_SIZE, o.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    });

    // Path
    ctx.strokeStyle = '#f9d71c';
    ctx.lineWidth = 8;
    ctx.beginPath();
    for(let i=0; i<path.length; i++) {
      const p = path[i];
      const px = p.x * TILE_SIZE + TILE_SIZE/2;
      const py = p.y * TILE_SIZE + TILE_SIZE/2;
      if(i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  // Draw towers
  function drawTowers() {
    towers.forEach(t => {
      // Tower base
      ctx.fillStyle = '#3a5b35';
      ctx.beginPath();
      ctx.arc(t.x, t.y, 20, 0, Math.PI * 2);
      ctx.fill();

      // Tower range circle (light green, transparent)
      ctx.fillStyle = 'rgba(58, 91, 53, 0.15)';
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
      ctx.fill();

      // Tower center detail - bee icon style circle
      ctx.fillStyle = '#f1c40f';
      ctx.beginPath();
      ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Draw projectiles
  function drawProjectiles() {
    projectiles.forEach(p => p.draw(ctx));
  }

  // Draw enemies
  function drawEnemies() {
    enemies.forEach(e => e.draw(ctx));
  }

  // Game Over display
  function displayGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = '#e74c3c';
    ctx.font = '48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', width/2, height/2);
    ctx.font = '24px Arial';
    ctx.fillText('Refresh to play again', width/2, height/2 + 40);
  }

  // Main update loop
  function update(time = 0) {
    if(!lastFrameTime) lastFrameTime = time;
    const dt = (time - lastFrameTime) / 1000;
    lastFrameTime = time;
    if(gameOver) {
      displayGameOver();
      return;
    }

    ctx.clearRect(0, 0, width, height);
    drawMap();

    // Spawn enemies
    if(enemiesToSpawn > 0 && time - lastEnemySpawn > enemySpawnInterval) {
      const enemyType = getRandomEnemyType();
      enemies.push(new Enemy(enemyType));
      enemiesToSpawn--;
      lastEnemySpawn = time;
    }

    // Update enemies
    for(let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      const reachedBase = enemy.update(dt, time);
      if(enemy.health <= 0) {
        money += enemy.reward;
        messageDiv.textContent = `Killed ${enemyTypes[enemy.type].name}, +$${enemy.reward}`;
        enemies.splice(i, 1);
        updateUI();
        continue;
      }
      if(reachedBase) {
        baseHealth--;
        enemies.splice(i, 1);
        updateUI();
        messageDiv.textContent = `An enemy reached your base! -1 health`;
        if(baseHealth <= 0) {
          gameOver = true;
          messageDiv.textContent = 'Game Over!';
        }
      }
    }

    // Update towers (target and shoot)
    towers.forEach(tower => {
      if(time - tower.lastShot > tower.fireRate) {
        // Find target in range
        let target = null;
        let closestDist = 9999;
        for(let enemy of enemies) {
          const dist = pointDistance(tower.x, tower.y, enemy.x, enemy.y);
          if(dist <= tower.range && dist < closestDist) {
            closestDist = dist;
            target = enemy;
          }
        }
        if(target) {
          projectiles.push(new Projectile(tower.x, tower.y, target, tower.damage, tower.slowEffect, tower.slowDuration));
          tower.lastShot = time;
        }
      }
    });

    // Update projectiles
    for(let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      const hit = p.update(dt);
      if(!p.active) {
        projectiles.splice(i, 1);
      }
    }

    drawTowers();
    drawEnemies();
    drawProjectiles();

    requestAnimationFrame(update);
  }

  // Start first wave and initialize UI
  function startGame() {
    baseHealth = BASE_HEALTH_START;
    money = INITIAL_MONEY;
    waveNumber = 0;
    enemies = [];
    towers = [];
    projectiles = [];
    gameOver = false;
    towerGrid = new Array(MAP_ROWS).fill(null).map(() => new Array(MAP_COLS).fill(false));
    selectedTowerType = null;
    selectedTower = null;
    placingTower = false;
    messageDiv.textContent = 'Select a tower to place.';
    updateUI();
    spawnWave();
    requestAnimationFrame(update);
  }

  // Wave progression: new wave starts automatically after all enemies dead
  function checkWaveProgress() {
    if(!gameOver && enemies.length === 0 && enemiesToSpawn === 0) {
      messageDiv.textContent = `Wave ${waveNumber} complete! Next wave in 3 seconds.`;
      setTimeout(() => {
        if(!gameOver) {
          spawnWave();
        }
      }, 3000);
    }
  }

  // Check wave progress every second
  setInterval(checkWaveProgress, 1000);

  startGame();
})();
