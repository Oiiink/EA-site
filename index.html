<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Color Wordle â€” TheColorAPI</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root { --bg:#0f0f0f; --card:#141414; --accent:#ff9a00; color-scheme: dark; }
html,body{height:100%}
body{
  margin:0;
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
  background:radial-gradient(circle at 10% 10%, #121216 0%, #0b0b0d 40%, #070707 100%);
  color:#fff;
  display:flex;
  align-items:flex-start;
  justify-content:center;
  padding:28px;
  box-sizing:border-box;
}
.app { width:560px; max-width:calc(100% - 40px); }
h1 { margin:0 0 6px 0; color:var(--accent); font-size:30px; }
.lead { color:#cfcfcf; margin:6px 0 14px 0; font-size:14px; }
.controls { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
.inputWrap{ position:relative; flex:1; }
input[type="text"]{
  width:100%;
  padding:12px 14px;
  border-radius:12px;
  border:1px solid #222;
  background:#0b0b0b;
  color:#fff;
  outline:none;
  font-size:15px;
}
input[type="text"]:focus{ box-shadow:0 0 10px rgba(255,154,0,0.12); border-color: rgba(255,154,0,0.32); }
.smallBtn { padding:10px 12px; border-radius:10px; background:var(--accent); color:#000; border:none; cursor:pointer; font-weight:700; }

/* preview + results area */
.toolbar { display:flex; gap:8px; align-items:center; margin-top:8px; }
.preview { width:64px; height:64px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background:#000; box-shadow: inset 0 -8px 18px rgba(0,0,0,0.6); }
.controlsRight{ display:flex; gap:6px; align-items:center; margin-left:auto; }

/* messages + list */
#resultMsg { margin-top:12px; font-weight:700; min-height:28px; color:#fff; }
.hint { color:#bdbdbd; font-size:13px; margin-top:8px; }
#guessList { margin-top:14px; display:flex; flex-direction:column; gap:8px; max-height:46vh; overflow:auto; padding-right:6px; }
.guessItem { display:flex; align-items:center; justify-content:space-between; background:var(--card); padding:10px; border-radius:10px; border:1px solid #222; }
.left { display:flex; gap:12px; align-items:center; }
.swatch { width:56px; height:56px; border-radius:8px; border:2px solid rgba(255,255,255,0.06); flex-shrink:0; cursor:pointer; }
.meta { font-size:13px; color:#eaeaea; }
.norm { font-size:12px; color:#bfbfbf; margin-top:6px; }
.similarity { font-weight:800; min-width:70px; text-align:right; color:#fff; font-size:14px; }
.correct { box-shadow:0 0 18px 3px rgba(0,255,128,0.12); border-color:#19d119; }
.bad { color:#ff6b6b; }
.good { color:#6bff9b; }
.small { font-size:12px; color:#aaa; margin-left:6px; }
.kbd { background:#222; padding:4px 8px; border-radius:6px; border:1px solid #333; font-size:12px; }

/* suggestions */
.suggestions { position:absolute; left:0; right:0; top:calc(100% + 8px); background:#0d0d0d; border:1px solid #222; border-radius:10px; max-height:240px; overflow:auto; z-index:60; padding:6px; display:none; }
.sugg { padding:8px 10px; cursor:pointer; border-radius:8px; }
.sugg:hover{ background:#111; }

/* footer */
footer { margin-top:12px; font-size:12px; color:#888; text-align:center; }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Color Wordle">
    <h1>Color Wordle â€” API Mode</h1>
    <div class="lead">Type any color phrase or hex. Press <span class="kbd">Enter</span> to submit. Try "the darkest blue", "very pale pink", or "#3498db".</div>

    <div class="controls">
      <div class="inputWrap">
        <input id="colorInput" placeholder="Try: red | light red | pinkie | the darkest blue | #ff33aa" autofocus aria-label="Color input">
        <div id="suggestions" class="suggestions" aria-hidden="true"></div>
      </div>

      <div class="controlsRight">
        <div class="preview" id="preview" aria-hidden="true" title="Color preview"></div>
        <button id="giveUp" class="smallBtn" title="Reveal secret color">Give up</button>
        <button id="refresh" class="smallBtn" title="Pick a new secret color">Refresh</button>
      </div>
    </div>

    <div id="resultMsg">Tip: natural-language parsing + TheColorAPI name lookup. Duplicate guesses blocked.</div>
    <div class="hint" id="hintLine">We accept CSS names + phrases (light, dark, pastel, deepest, pale, muted, bright, very). Click a swatch to copy.</div>

    <div id="guessList" aria-live="polite"></div>

    <footer>Secret color is generated randomly and looked up via TheColorAPI. Developer tools cannot be fully blocked; secret is not logged to console.</footer>
  </div>

<script>
/* ---------------------------
  Color Wordle â€” API-powered
   - Option A: TheColorAPI
   - Natural-language parsing -> hex
   - Enter submits
   - Total guesses, give up, refresh
--------------------------- */

/* ---------- helpers from your parser (lightly adapted) ---------- */
const modifiersList = ["light","lighter","lightest","dark","darker","darkest","pale","pastel","muted","deep","very","bright","brightest","soft","desaturated","dull","rich","vivid","neon","ultra","slightly","ish"];

function hexPad(h) { return h.replace("#","").toLowerCase().padStart(6,"0"); }
function randomHex() { return "#" + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,"0"); }

function isValidCssColor(input) {
  if (!input || typeof input !== "string") return false;
  const s = new Option().style;
  s.color = input;
  return !!s.color;
}
function normalizedColor(colorStr) {
  const ctx = document.createElement("canvas").getContext("2d");
  ctx.fillStyle = colorStr;
  return ctx.fillStyle;
}
function hexToRgb(hex){
  hex = hex.replace("#",""); if (hex.length===3) hex = hex.split("").map(c=>c+c).join("");
  const n = parseInt(hex,16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToHsl({r,g,b}) {
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  if (max!==min) {
    const d=max-min;
    s = l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h /= 6;
  }
  return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) };
}
function hslToRgb({h,s,l}) {
  h = ((h%360)+360)%360; s/=100; l/=100;
  if (s===0){ const v=Math.round(l*255); return {r:v,g:v,b:v}; }
  const q = l<0.5 ? l*(1+s) : l + s - l*s;
  const p = 2*l - q;
  const hk = h/360;
  const t = [hk+1/3, hk, hk-1/3].map(tc => {
    if (tc<0) tc+=1; if (tc>1) tc-=1;
    if (tc < 1/6) return p + (q-p)*6*tc;
    if (tc < 1/2) return q;
    if (tc < 2/3) return p + (q-p)*(2/3 - tc)*6;
    return p;
  });
  return { r: Math.round(t[0]*255), g: Math.round(t[1]*255), b: Math.round(t[2]*255) };
}

/* ---------- natural-language parsing (fallback, then API) ---------- */
/* This is a compact parser: first tries CSS parse, then tries to extract base word(s)
   and apply modifiers (light/dark/pale/etc.) to shift HSL. It returns a hex string or null.
*/
function parseNaturalColor(inputRaw) {
  if (!inputRaw) return null;
  const raw = inputRaw.trim().toLowerCase();

  // allow direct hex or CSS color names first
  if (raw.startsWith("#")) {
    const m = raw.replace("#","").trim();
    if (/^[0-9a-f]{3}$/i.test(m)) return "#" + m.split("").map(c=>c+c).join("");
    if (/^[0-9a-f]{6}$/i.test(m)) return "#" + m;
    return null;
  }
  if (isValidCssColor(raw)) return normalizedColor(raw);

  // tokenization
  const tokens = raw.split(/[\s,.-]+/).filter(Boolean);
  const stopwords = new Set(["the","a","an","of","ish","most","really","super","very","my"]);
  const mods = [];
  const words = [];
  for (let t of tokens) {
    if (stopwords.has(t)) continue;
    if (modifiersList.includes(t) || t.endsWith("er") && modifiersList.includes(t.replace(/er$/,""))) mods.push(t);
    else words.push(t);
  }
  if (!words.length) return null;

  // Build candidate base string (try longest combos first)
  // We'll try to use the browser CSS parsing for joined phrases (e.g., "midnightblue", "lightpink")
  for (let len = Math.min(3, words.length); len>0; len--) {
    for (let i=0;i<=words.length-len;i++) {
      const spaced = words.slice(i,i+len).join(" ");
      const joined = words.slice(i,i+len).join("");
      if (isValidCssColor(spaced)) return normalizedColor(spaced);
      if (isValidCssColor(joined)) return normalizedColor(joined);
    }
  }

  // If still not found, fallback to using TheColorAPI via descriptive phrase:
  // We'll attempt to form a reasonable color by using the primary noun (last word)
  // and letting API try to resolve the phrase (handled later in code).
  // For now return null to indicate we should call API with a generated hex or the phrase.
  return null;
}

/* ---------- TheColorAPI helper ---------- */
async function fetchColorInfoFromAPI(hexOrPhrase) {
  // If hexOrPhrase looks like a hex, call /id?hex=
  // Otherwise call the API's name endpoint by searching with a hex created from phrase? TheColorAPI doesn't have a direct 'search by phrase' endpoint,
  // so when phrase cannot be parsed to hex we will ask API about a random hex nearby or fallback to generating a hex client-side and using API to name it.
  try {
    // hex case:
    if (typeof hexOrPhrase === "string" && /^#?[0-9a-f]{3}$|#?[0-9a-f]{6}$/i.test(hexOrPhrase)) {
      const clean = hexPad(hexOrPhrase);
      const res = await fetch(`https://www.thecolorapi.com/id?hex=${clean}`);
      if (!res.ok) return null;
      const json = await res.json();
      return {
        hex: json.hex.value || ("#"+clean),
        name: (json.name && json.name.value) || null,
        rgb: json.rgb,
        hsl: json.hsl
      };
    }

    // phrase case: try to get a hex by using a heuristic -- ask API with a random hex near a color descriptor is not supported.
    // We'll return null so the caller can try: either use browser parsing, or generate a hex and call API for name.
    return null;
  } catch (e) {
    return null;
  }
}

/* ---------- similarity metric using HSL distance ---------- */
function hslDistancePercent(hslA, hslB) {
  // hslA, hslB = {h,s,l} with 0-360,0-100,0-100
  const dh = Math.min(Math.abs(hslA.h - hslB.h), 360 - Math.abs(hslA.h - hslB.h)) / 180; // normalized [0..1]
  const ds = Math.abs(hslA.s - hslB.s) / 100;
  const dl = Math.abs(hslA.l - hslB.l) / 100;
  // weighted sum (hue more important)
  const dist = Math.sqrt((dh*dh)*0.6 + (ds*ds)*0.25 + (dl*dl)*0.15);
  const pct = Math.round((1 - Math.min(1, dist)) * 100);
  return pct;
}

/* ---------- UI & state ---------- */
const input = document.getElementById("colorInput");
const suggestions = document.getElementById("suggestions");
const preview = document.getElementById("preview");
const guessList = document.getElementById("guessList");
const resultMsg = document.getElementById("resultMsg");
const hintLine = document.getElementById("hintLine");
const btnGive = document.getElementById("giveUp");
const btnRefresh = document.getElementById("refresh");

let secretHex = null;
let secretName = null;
let secretHsl = null;

let totalGuesses = 0;
const guessedTypedSet = new Set();
const guessedNormSet = new Set();

/* ---------- pick a secret color (generate random hex, ask TheColorAPI for its official name) ---------- */
async function pickSecret() {
  secretHex = randomHex();
  // We do NOT log the secret anywhere (to make casual discovery harder).
  // Note: a determined user can still inspect network requests or the JS runtime â€” that cannot be fully prevented client-side.
  const info = await fetchColorInfoFromAPI(secretHex);
  if (info && info.hex) {
    secretHex = info.hex;
    secretName = info.name || null;
    secretHsl = info.hsl ? { h: info.hsl.h, s: info.hsl.s, l: info.hsl.l } : rgbToHsl(hexToRgb(secretHex));
  } else {
    // fallback: compute HSL locally
    secretName = null;
    secretHsl = rgbToHsl(hexToRgb(secretHex));
  }
  totalGuesses = 0;
  guessedTypedSet.clear(); guessedNormSet.clear();
  guessList.innerHTML = "";
  resultMsg.textContent = "New secret chosen â€” start guessing!";
  preview.style.background = "#000";
}
btnRefresh.addEventListener("click", () => { pickSecret(); });

/* ---------- query handler: called when user submits an input ---------- */
async function handleGuessRaw(raw) {
  if (!raw || !raw.trim()) {
    resultMsg.textContent = "Type something (e.g., 'red' or '#ff0066').";
    return;
  }
  const typed = raw.trim();
  const typedKey = typed.toLowerCase();

  if (guessedTypedSet.has(typedKey)) {
    resultMsg.innerHTML = `<span class="bad">You already guessed "<strong>${escapeHtml(typed)}</strong>".</span>`;
    return;
  }

  // Try CSS / direct parse first or natural parser
  let hex = null;
  if (isValidCssColor(typed)) {
    hex = normalizedColor(typed); // returns #rrggbb (browser normalized)
  } else {
    const parsed = parseNaturalColor(typed);
    if (parsed) hex = parsed;
    else {
      // attempt to ask API by generating a hex from phrase fallback:
      // strategy: hash the phrase to produce a deterministic hex, then ask API for name.
      const hashHex = deterministicHexFromString(typed);
      hex = hashHex;
    }
  }

  // Normalize hex format (#rrggbb)
  if (hex && /^#?[0-9a-f]{3}$/i.test(hex)) hex = "#" + hex.replace("#","").replace(/^(.)(.)(.)$/,"$1$1$2$2$3$3");
  if (hex && /^#?[0-9a-f]{6}$/i.test(hex) === false) {
    resultMsg.innerHTML = `<span class="bad">Couldn't interpret "<strong>${escapeHtml(typed)}</strong>". Try a different phrase or a hex like #RRGGBB.</span>`;
    return;
  }
  hex = "#" + hex.replace("#","").toLowerCase().slice(0,6);

  // Check duplicate normalized color
  if (guessedNormSet.has(hex)) {
    resultMsg.innerHTML = `<span class="bad">That color (normalized <code>${escapeHtml(hex)}</code>) was already guessed.</span>`;
    return;
  }

  // Ask TheColorAPI to get official name & HSL for this hex (if available)
  let apiInfo = await fetchColorInfoFromAPI(hex);
  let userName = apiInfo && apiInfo.name ? apiInfo.name : null;
  let userHsl = apiInfo && apiInfo.hsl ? { h: apiInfo.hsl.h, s: apiInfo.hsl.s, l: apiInfo.hsl.l } : rgbToHsl(hexToRgb(hex));

  // record guess
  guessedTypedSet.add(typedKey);
  guessedNormSet.add(hex);
  totalGuesses++;

  // update preview & list
  preview.style.background = hex;
  addGuessToList(typed, hex, userName, userHsl);

  // compute similarity %
  const sim = secretHsl ? hslDistancePercent(userHsl, secretHsl) : 0;

  if (sim === 100) {
    resultMsg.innerHTML = `<span class="good">ðŸŽ‰ Correct! ${ userName ? escapeHtml(userName) + " " : "" }(${escapeHtml(hex)})</span>`;
  } else {
    resultMsg.innerHTML = `You're <strong>${sim}%</strong> close. Total guesses: <strong>${totalGuesses}</strong>.`;
  }

  // clear input
  input.value = "";
  suggestions.style.display = "none";
  input.focus();
}

/* ---------- UI: add guess entry ---------- */
function addGuessToList(typedText, normalizedHex, officialName, hsl) {
  const item = document.createElement("div");
  item.className = "guessItem";

  const left = document.createElement("div"); left.className = "left";
  const sw = document.createElement("div"); sw.className = "swatch"; sw.style.background = normalizedHex;
  sw.title = `Click to copy ${normalizedHex}`;
  sw.addEventListener("click", ()=> {
    navigator.clipboard?.writeText(normalizedHex).then(()=> {
      hintLine.textContent = `Copied ${normalizedHex} to clipboard`;
      setTimeout(()=> hintLine.textContent = 'We accept CSS + natural phrases (light/dark/pastel/etc).', 1400);
    }).catch(()=>{});
  });

  const meta = document.createElement("div"); meta.className = "meta";
  const typedEl = document.createElement("div"); typedEl.textContent = typedText;
  const normEl = document.createElement("div"); normEl.className = "norm";
  normEl.textContent = `${normalizedHex}${officialName ? " â€” " + officialName : ""}`;
  meta.appendChild(typedEl); meta.appendChild(normEl);

  left.appendChild(sw); left.appendChild(meta);

  const sim = document.createElement("div"); sim.className = "similarity"; sim.textContent = `#${totalGuesses}`;
  item.appendChild(left); item.appendChild(sim);

  guessList.prepend(item);
}

/* ---------- Give up: reveal official name + hex ---------- */
btnGive.addEventListener("click", async () => {
  // If we don't have secretName from API, try to fetch it now
  if (!secretName) {
    const info = await fetchColorInfoFromAPI(secretHex);
    if (info && info.name) secretName = info.name;
  }
  resultMsg.innerHTML = `<span class="bad">Give up â€” secret: <strong>${escapeHtml(secretName || "Unnamed")}</strong> (${escapeHtml(secretHex)})</span>`;
  preview.style.background = secretHex;
});

/* ---------- input events: Enter submits, suggestions ---------- */
input.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    handleGuessRaw(input.value);
  } else if (e.key === "ArrowDown") {
    // focus first suggestion
    const first = suggestions.querySelector(".sugg");
    if (first) first.focus();
  }
});

input.addEventListener("input", () => {
  const q = input.value.trim().toLowerCase();
  suggestions.innerHTML = "";
  if (!q) { suggestions.style.display = "none"; return; }

  // simple suggestions: show CSS keyword matches from browser (try a small list)
  // We'll use a tiny curated list to avoid huge memory; API resolves names anyway.
  const curated = ["red","blue","green","pink","purple","navy","teal","azure","lavender","salmon","coral","mint","olive","maroon","gold","silver","indigo"];
  const matches = curated.filter(k => k.includes(q)).slice(0,12);

  for (const m of matches) {
    const el = document.createElement("div");
    el.tabIndex = 0;
    el.className = "sugg";
    el.textContent = m;
    el.onclick = ()=> { input.value = m; suggestions.style.display = "none"; input.focus(); };
    el.onkeydown = (ev)=> { if (ev.key==="Enter"){ input.value=m; suggestions.style.display="none"; input.focus(); } };
    suggestions.appendChild(el);
  }
  suggestions.style.display = matches.length ? "block" : "none";
});

/* ---------- utility helpers ---------- */
function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }

/* ---------- deterministic hex from phrase (fallback) ---------- */
function deterministicHexFromString(s) {
  // simple hash -> hex
  let h=2166136261 >>> 0;
  for (let i=0;i<s.length;i++){ h = Math.imul(h ^ s.charCodeAt(i), 16777619) >>> 0; }
  const r = (h & 0xFF0000) >> 16;
  const g = (h & 0x00FF00) >> 8;
  const b = (h & 0x0000FF);
  return "#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");
}

/* ---------- fetch color info from TheColorAPI for hex; returns {hex,name,rgb,hsl} or null ---------- */
async function fetchColorInfoFromAPI(hex) {
  try {
    const clean = hexPad(hex);
    const resp = await fetch(`https://www.thecolorapi.com/id?hex=${clean}`);
    if (!resp.ok) return null;
    const j = await resp.json();
    return { hex: j.hex.value, name: j.name && j.name.value ? j.name.value : null, rgb: j.rgb, hsl: j.hsl };
  } catch(e){
    return null;
  }
}

/* ---------- pick initial secret on load ---------- */
(async function init(){
  // pick a secret hex and ask TheColorAPI to name it
  await pickSecret();
})();

/* ---------- small note about devtools / secrecy ---------- */
/*
  IMPORTANT: You asked to "make it so you cant go on developer mode to get the color".
  Short, honest answer: it's impossible to absolutely prevent someone from inspecting network requests
  or the JavaScript runtime if the secret is chosen client-side. Measures taken here to reduce casual
  exposure:
    - We DO NOT log the secret to console.
    - We do not place the secret in any visible DOM element.
    - The secret name is fetched from the API but kept in a local variable.
  If you need true secrecy (server-side only), the secret must be stored on a server, and the server should
  evaluate guesses (so the secret never reaches the client).
*/

</script>
</body>
</html>
