<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Market Simulator - One Stock & Scheduled Orders</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: #1e1e1e;
      color: #eee;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
      overflow-x: hidden;
    }
    h1 {
      text-align: center;
      margin: 15px 0 8px 0;
      font-weight: 600;
      color: #f5f5f5;
    }
    #tabs {
      max-width: 1100px;
      margin: 0 auto 15px;
      display: flex;
      justify-content: center;
      gap: 24px;
    }
    .tab {
      padding: 8px 20px;
      cursor: pointer;
      border-radius: 8px 8px 0 0;
      background: #333;
      font-weight: 700;
      user-select: none;
      color: #ccc;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .tab.active {
      background: #0a84ff;
      color: white;
      box-shadow: 0 4px 8px rgba(10,132,255,0.6);
    }
    #container {
      max-width: 1100px;
      margin: 0 auto 40px;
      background: #252526;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.7);
      min-height: 450px;
    }
    #balance {
      text-align: center;
      font-size: 1.2rem;
      margin-bottom: 18px;
      font-weight: 600;
      color: #ddd;
      user-select: text;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 25px;
    }
    th, td {
      text-align: center;
      padding: 10px 8px;
      border-bottom: 1px solid #444;
      vertical-align: middle;
      user-select: text;
    }
    th {
      background: #3c3c3c;
      font-weight: 700;
      font-size: 14px;
      color: #ccc;
    }
    td {
      font-size: 13px;
      color: #bbb;
    }
    .price-up {
      color: #4caf50;
      font-weight: 600;
    }
    .price-down {
      color: #f44336;
      font-weight: 600;
    }
    input[type=number] {
      width: 60px;
      padding: 6px;
      border-radius: 4px;
      border: none;
      background: #333;
      color: #eee;
      font-weight: 600;
      font-size: 13px;
      text-align: center;
      outline: none;
      transition: background-color 0.2s ease;
      user-select: text;
    }
    input[type=number]:focus {
      background: #444;
    }
    button {
      background-color: #0a84ff;
      border: none;
      padding: 6px 12px;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      font-weight: 700;
      font-size: 13px;
      transition: background-color 0.3s ease;
      user-select: none;
    }
    button:hover {
      background-color: #006edc;
    }
    #log {
      max-width: 1100px;
      margin: 0 auto;
      background: #181818;
      padding: 10px 15px;
      border-radius: 6px;
      box-shadow: inset 0 0 15px rgba(255,255,255,0.05);
      height: 140px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      color: #bbb;
      user-select: text;
    }
    canvas.chartCanvas {
      display: block;
      margin: 10px auto 8px auto;
      background: #121212;
      border: 1px solid #333;
      border-radius: 6px;
      cursor: grab;
    }
    #chartContainer {
      user-select: none;
      position: relative;
    }
    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      font-family: monospace;
      color: #eee;
      display: none;
      white-space: nowrap;
      box-shadow: 0 0 6px rgba(0,0,0,0.8);
      z-index: 10;
      border: 1px solid #444;
      user-select: none;
    }
    /* Pending order badge */
    .pending-order {
      position: relative;
      display: inline-block;
      margin-left: 6px;
      font-size: 11px;
      font-weight: 700;
      color: #0af;
      background: rgba(10, 132, 255, 0.15);
      border-radius: 10px;
      padding: 2px 6px;
      user-select: none;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>Stock Market Simulator</h1>
  <div id="tabs">
    <div id="tab-market" class="tab active">Market</div>
    <div id="tab-portfolio" class="tab">Portfolio Summary</div>
  </div>

  <div id="container">
    <div id="balance">Cash: $1000.00 | Portfolio Value: $0.00 | Total: $1000.00</div>

    <div id="market-view">
      <table>
        <thead>
          <tr>
            <th>Select</th>
            <th>Stock</th>
            <th>Price ($)</th>
            <th>Chart & Volume</th>
            <th>Your Shares</th>
            <th>Buy</th>
            <th>Sell</th>
          </tr>
        </thead>
        <tbody id="stockBody"></tbody>
      </table>
    </div>

    <div id="portfolio-view" style="display:none;">
      <table>
        <thead>
          <tr>
            <th>Stock</th>
            <th>Shares Owned</th>
            <th>Current Price</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody id="portfolioBody"></tbody>
      </table>
      <div style="text-align:center; margin-top: 10px; font-size: 1.1rem; color: #ddd;">
        <strong>Total Portfolio Value:</strong> $<span id="portfolioTotal">0.00</span><br/>
        <strong>Cash:</strong> $<span id="portfolioCash">0.00</span><br/>
        <strong>Overall Total:</strong> $<span id="portfolioOverall">0.00</span>
      </div>
      <div style="margin-top: 15px; font-size: 14px; color: #aaa; user-select: text;">
        <h3>Pending Orders</h3>
        <ul id="pendingOrdersList" style="list-style:none; padding-left:0; max-height:150px; overflow-y:auto;"></ul>
      </div>
    </div>
  </div>

  <div id="log"></div>

<script>
  // -- DATA SETUP --

  let cash = 1000;

  // Only one stock can be selected for investing
  let selectedStockSymbol = null;

  const stocks = [
    { symbol: "APL", name: "Apple", price: 150, owned: 0, history: [] },
    { symbol: "GGL", name: "Google", price: 2800, owned: 0, history: [] },
    { symbol: "TSL", name: "Tesla", price: 720, owned: 0, history: [] },
    { symbol: "AMZ", name: "Amazon", price: 3400, owned: 0, history: [] },
    { symbol: "MSF", name: "Microsoft", price: 300, owned: 0, history: [] },
  ];

  const balanceEl = document.querySelector("#balance");
  const stockBody = document.querySelector("#stockBody");
  const portfolioBody = document.querySelector("#portfolioBody");
  const portfolioTotalEl = document.querySelector("#portfolioTotal");
  const portfolioCashEl = document.querySelector("#portfolioCash");
  const portfolioOverallEl = document.querySelector("#portfolioOverall");
  const pendingOrdersList = document.querySelector("#pendingOrdersList");
  const log = document.querySelector("#log");

  // -- PENDING ORDERS --

  let pendingOrders = []; // {id, type:'buy'|'sell', stockSymbol, shares, executeTime (Date)}

  // -- UTILS --

  function formatMoney(num) {
    return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function logEvent(text) {
    const time = new Date().toLocaleTimeString();
    log.textContent = `[${time}] ${text}\n` + log.textContent;
  }

  // -- CHART CONSTANTS --

  const CHART_WIDTH = 300;
  const CHART_HEIGHT = 150;
  const VOLUME_HEIGHT = 40;
  const PADDING = 30;

  // -- STOCK ROW + CANVAS CREATION --

  function createStockRow(stock) {
    const tr = document.createElement("tr");
    tr.id = `row-${stock.symbol}`;

    // Selection radio - only one stock allowed to invest in
    const tdSelect = document.createElement("td");
    const radio = document.createElement("input");
    radio.type = "radio";
    radio.name = "select-stock";
    radio.value = stock.symbol;
    radio.checked = stock.symbol === selectedStockSymbol;
    radio.onchange = () => {
      selectedStockSymbol = stock.symbol;
      renderStocks();
      updateBalance();
      logEvent(`Selected stock for investment: ${stock.symbol}`);
    };
    tdSelect.appendChild(radio);

    const tdSymbol = document.createElement("td");
    tdSymbol.textContent = `${stock.name} (${stock.symbol})`;

    const tdPrice = document.createElement("td");
    tdPrice.id = `price-${stock.symbol}`;
    tdPrice.textContent = formatMoney(stock.price);

    const tdChart = document.createElement("td");
    tdChart.style.minWidth = CHART_WIDTH + "px";
    tdChart.style.userSelect = "none";
    tdChart.style.position = "relative";

    // Chart container + canvas + tooltip
    const chartContainer = document.createElement("div");
    chartContainer.style.position = "relative";
    chartContainer.id = `chartContainer-${stock.symbol}`;

    const canvas = document.createElement("canvas");
    canvas.className = "chartCanvas";
    canvas.width = CHART_WIDTH;
    canvas.height = CHART_HEIGHT + VOLUME_HEIGHT;
    canvas.id = `chart-${stock.symbol}`;

    const tooltip = document.createElement("div");
    tooltip.id = `tooltip-${stock.symbol}`;
    tooltip.style.position = "absolute";
    tooltip.style.pointerEvents = "none";
    tooltip.style.display = "none";
    tooltip.style.background = "rgba(30,30,30,0.9)";
    tooltip.style.color = "#eee";
    tooltip.style.padding = "6px 10px";
    tooltip.style.fontSize = "12px";
    tooltip.style.borderRadius = "6px";
    tooltip.style.border = "1px solid #444";
    tooltip.style.whiteSpace = "nowrap";
    tooltip.style.userSelect = "none";

    chartContainer.appendChild(canvas);
    chartContainer.appendChild(tooltip);
    tdChart.appendChild(chartContainer);

    const tdOwned = document.createElement("td");
    tdOwned.id = `owned-${stock.symbol}`;
    tdOwned.textContent = stock.owned;

    // Buy input & button + pending order indicator
    const tdBuy = document.createElement("td");
    const buyInput = document.createElement("input");
    buyInput.type = "number";
    buyInput.min = "1";
    buyInput.value = "1";
    buyInput.id = `buy-input-${stock.symbol}`;
    buyInput.style.marginRight = "6px";

    const buyBtn = document.createElement("button");
    buyBtn.textContent = "Buy";
    buyBtn.onclick = () => scheduleOrder(stock.symbol, 'buy', buyInput.value);
    tdBuy.appendChild(buyInput);
    tdBuy.appendChild(buyBtn);

    const buyPendingSpan = document.createElement("span");
    buyPendingSpan.id = `pending-buy-${stock.symbol}`;
    buyPendingSpan.className = "pending-order";
    buyPendingSpan.style.display = "none";
    tdBuy.appendChild(buyPendingSpan);

    // Sell input & button + pending order indicator
    const tdSell = document.createElement("td");
    const sellInput = document.createElement("input");
    sellInput.type = "number";
    sellInput.min = "1";
    sellInput.value = "1";
    sellInput.id = `sell-input-${stock.symbol}`;
    sellInput.style.marginRight = "6px";

    const sellBtn = document.createElement("button");
    sellBtn.textContent = "Sell";
    sellBtn.onclick = () => scheduleOrder(stock.symbol, 'sell', sellInput.value);
    tdSell.appendChild(sellInput);
    tdSell.appendChild(sellBtn);

    const sellPendingSpan = document.createElement("span");
    sellPendingSpan.id = `pending-sell-${stock.symbol}`;
    sellPendingSpan.className = "pending-order";
    sellPendingSpan.style.display = "none";
    tdSell.appendChild(sellPendingSpan);

    tr.appendChild(tdSelect);
    tr.appendChild(tdSymbol);
    tr.appendChild(tdPrice);
    tr.appendChild(tdChart);
    tr.appendChild(tdOwned);
    tr.appendChild(tdBuy);
    tr.appendChild(tdSell);

    return tr;
  }

  // -- RENDER STOCKS --

  function renderStocks() {
    stockBody.innerHTML = "";
    stocks.forEach(stock => {
      stockBody.appendChild(createStockRow(stock));
      drawChart(stock);
      setupTooltip(stock);
      setupZoomPan(stock);
    });
  }

  // -- BUY & SELL LOGIC (Immediate execution) --

  function buyStock(symbol, amount) {
    const stock = stocks.find(s => s.symbol === symbol);
    const cost = stock.price * amount;
    if (cost > cash) {
      alert(`Not enough cash to buy ${amount} shares of ${stock.symbol}`);
      return false;
    }
    stock.owned += amount;
    cash -= cost;
    logEvent(`Bought ${amount} shares of ${stock.symbol} for $${formatMoney(cost)}`);
    return true;
  }

  function sellStock(symbol, amount) {
    const stock = stocks.find(s => s.symbol === symbol);
    if (amount > stock.owned) {
      alert(`You don't own ${amount} shares of ${stock.symbol}`);
      return false;
    }
    const gain = stock.price * amount;
    stock.owned -= amount;
    cash += gain;
    logEvent(`Sold ${amount} shares of ${stock.symbol} for $${formatMoney(gain)}`);
    return true;
  }

  // -- SCHEDULED ORDERS --

  let orderIdCounter = 0;

  function scheduleOrder(symbol, type, amountStr) {
    if (selectedStockSymbol !== symbol) {
      alert("You can only invest in the selected stock.");
      return;
    }
    const amount = parseInt(amountStr);
    if (isNaN(amount) || amount < 1) {
      alert("Enter a valid amount");
      return;
    }
    const stock = stocks.find(s => s.symbol === symbol);

    // For buys, check if you have enough cash now (allow negative so they can try, or block?)
    if (type === 'buy' && stock.price * amount > cash) {
      alert("You do not have enough cash now to buy that amount.");
      return;
    }
    if (type === 'sell' && amount > stock.owned) {
      alert("You do not own enough shares to sell that amount.");
      return;
    }

    // Prompt user for delay in minutes
    let minutesStr = prompt(`Enter delay in minutes for this ${type} order (e.g. 0 for immediate):`, "0");
    if (minutesStr === null) return; // cancelled
    const delayMinutes = parseFloat(minutesStr);
    if (isNaN(delayMinutes) || delayMinutes < 0) {
      alert("Enter a valid non-negative number of minutes");
      return;
    }

    const executeTime = Date.now() + delayMinutes * 60000;
    const order = {
      id: orderIdCounter++,
      type,
      stockSymbol: symbol,
      shares: amount,
      executeTime,
      status: 'pending'
    };
    pendingOrders.push(order);
    updatePendingIndicators();
    logEvent(`Scheduled ${type} order for ${amount} shares of ${symbol} in ${delayMinutes} minute(s).`);

    if(delayMinutes === 0) {
      // Immediate execution on next tick
      processPendingOrders();
    }
  }

  function updatePendingIndicators() {
    stocks.forEach(stock => {
      const buyPending = pendingOrders.some(o => o.stockSymbol === stock.symbol && o.type === 'buy' && o.status === 'pending');
      const sellPending = pendingOrders.some(o => o.stockSymbol === stock.symbol && o.type === 'sell' && o.status === 'pending');

      const buySpan = document.getElementById(`pending-buy-${stock.symbol}`);
      const sellSpan = document.getElementById(`pending-sell-${stock.symbol}`);

      if (buyPending) {
        buySpan.style.display = "inline-block";
        buySpan.textContent = "Pending";
      } else {
        buySpan.style.display = "none";
      }
      if (sellPending) {
        sellSpan.style.display = "inline-block";
        sellSpan.textContent = "Pending";
      } else {
        sellSpan.style.display = "none";
      }
    });
  }

  // -- PROCESS PENDING ORDERS --

  function processPendingOrders() {
    const now = Date.now();
    let changed = false;
    for (let order of pendingOrders) {
      if (order.status === 'pending' && order.executeTime <= now) {
        if (order.type === 'buy') {
          // Check cash again (maybe price changed)
          const stock = stocks.find(s => s.symbol === order.stockSymbol);
          const cost = stock.price * order.shares;
          if (cost <= cash) {
            stock.owned += order.shares;
            cash -= cost;
            logEvent(`Executed BUY order: ${order.shares} shares of ${order.stockSymbol} at $${formatMoney(stock.price)} each, total $${formatMoney(cost)}`);
            order.status = 'executed';
          } else {
            logEvent(`BUY order for ${order.shares} shares of ${order.stockSymbol} failed due to insufficient cash.`);
            order.status = 'failed';
          }
        } else if (order.type === 'sell') {
          const stock = stocks.find(s => s.symbol === order.stockSymbol);
          if (order.shares <= stock.owned) {
            const gain = stock.price * order.shares;
            stock.owned -= order.shares;
            cash += gain;
            logEvent(`Executed SELL order: ${order.shares} shares of ${order.stockSymbol} at $${formatMoney(stock.price)} each, total $${formatMoney(gain)}`);
            order.status = 'executed';
          } else {
            logEvent(`SELL order for ${order.shares} shares of ${order.stockSymbol} failed due to insufficient shares.`);
            order.status = 'failed';
          }
        }
        changed = true;
      }
    }
    if (changed) {
      // Remove executed/failed orders after showing
      pendingOrders = pendingOrders.filter(o => o.status === 'pending');
      updatePendingIndicators();
      updateBalance();
      renderPortfolio();
    }
  }

  // -- RENDER PORTFOLIO --

  function renderPortfolio() {
    portfolioBody.innerHTML = "";
    let totalValue = 0;
    stocks.forEach(stock => {
      if (stock.owned > 0) {
        const row = document.createElement("tr");

        const tdSymbol = document.createElement("td");
        tdSymbol.textContent = `${stock.name} (${stock.symbol})`;

        const tdOwned = document.createElement("td");
        tdOwned.textContent = stock.owned;

        const tdPrice = document.createElement("td");
        tdPrice.textContent = formatMoney(stock.price);

        const tdValue = document.createElement("td");
        const value = stock.price * stock.owned;
        tdValue.textContent = formatMoney(value);
        totalValue += value;

        row.appendChild(tdSymbol);
        row.appendChild(tdOwned);
        row.appendChild(tdPrice);
        row.appendChild(tdValue);
        portfolioBody.appendChild(row);
      }
    });
    portfolioTotalEl.textContent = formatMoney(totalValue);
    portfolioCashEl.textContent = formatMoney(cash);
    portfolioOverallEl.textContent = formatMoney(totalValue + cash);

    // Pending orders list
    pendingOrdersList.innerHTML = "";
    if (pendingOrders.length === 0) {
      pendingOrdersList.innerHTML = "<li>No pending orders.</li>";
    } else {
      pendingOrders.forEach(order => {
        const li = document.createElement("li");
        const inSeconds = Math.max(0, Math.round((order.executeTime - Date.now()) / 1000));
        const mins = Math.floor(inSeconds / 60);
        const secs = inSeconds % 60;
        li.textContent = `${order.type.toUpperCase()} ${order.shares} shares of ${order.stockSymbol} in ${mins}m ${secs}s`;
        pendingOrdersList.appendChild(li);
      });
    }
  }

  // -- BALANCE DISPLAY --

  function updateBalance() {
    const portfolioValue = stocks.reduce((acc, s) => acc + s.price * s.owned, 0);
    balanceEl.textContent = `Cash: $${formatMoney(cash)} | Portfolio Value: $${formatMoney(portfolioValue)} | Total: $${formatMoney(cash + portfolioValue)}`;

    // Update owned shares count in stock list
    stocks.forEach(stock => {
      const tdOwned = document.getElementById(`owned-${stock.symbol}`);
      if (tdOwned) tdOwned.textContent = stock.owned;
      const tdPrice = document.getElementById(`price-${stock.symbol}`);
      if (tdPrice) tdPrice.textContent = formatMoney(stock.price);
    });
  }

  // -- CHART RENDERING --

  // We'll keep zoom & pan disabled for simplicity now

  function drawChart(stock) {
    const canvas = document.getElementById(`chart-${stock.symbol}`);
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    ctx.clearRect(0, 0, width, height);

    const priceHeight = CHART_HEIGHT - PADDING;
    const volumeHeight = VOLUME_HEIGHT;
    const padding = PADDING;

    // Use history data
    const candles = stock.history;
    if (candles.length < 2) return;

    const candleCount = candles.length;
    const candleWidth = (width - 2 * padding) / candleCount * 0.7;
    const candleStep = (width - 2 * padding) / candleCount;

    // Price scale
    let minPrice = Math.min(...candles.map(c => c.low));
    let maxPrice = Math.max(...candles.map(c => c.high));
    if (minPrice === maxPrice) maxPrice += 1;

    // Volume scale
    let maxVolume = Math.max(...candles.map(c => c.volume || 0));
    if (maxVolume === 0) maxVolume = 1;

    function scalePrice(y) {
      return priceHeight - ((y - minPrice) / (maxPrice - minPrice)) * priceHeight + padding;
    }
    function scaleVolume(v) {
      return volumeHeight * (v / maxVolume);
    }

    // Draw background grid lines for price
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 1;
    ctx.font = "10px monospace";
    ctx.fillStyle = "#888";
    ctx.textAlign = "right";

    for (let i = 0; i <= 4; i++) {
      let p = minPrice + (maxPrice - minPrice) * i / 4;
      let y = scalePrice(p);
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(width - padding, y);
      ctx.stroke();
      ctx.fillText(p.toFixed(2), padding - 5, y + 3);
    }

    // Draw volume label
    ctx.fillStyle = "#555";
    ctx.textAlign = "left";
    ctx.font = "9px monospace";
    ctx.fillText("Vol", padding, priceHeight + padding + 12);

    // Draw candles & volume bars
    candles.forEach((candle, i) => {
      const x = padding + i * candleStep + (candleStep - candleWidth) / 2;

      const up = candle.close >= candle.open;
      const color = up ? "#4caf50" : "#f44336";

      // Candle wick (high-low)
      const yHigh = scalePrice(candle.high);
      const yLow = scalePrice(candle.low);
      const yOpen = scalePrice(candle.open);
      const yClose = scalePrice(candle.close);
      const bodyTop = Math.min(yOpen, yClose);
      const bodyHeight = Math.max(1, Math.abs(yClose - yOpen));

      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + candleWidth / 2, yHigh);
      ctx.lineTo(x + candleWidth / 2, yLow);
      ctx.stroke();

      // Candle body
      ctx.fillStyle = color;
      ctx.fillRect(x, bodyTop, candleWidth, bodyHeight);

      // Volume bar
      if (candle.volume) {
        const volHeight = scaleVolume(candle.volume);
        ctx.fillStyle = color + "aa";
        ctx.fillRect(x, priceHeight + padding + volumeHeight - volHeight, candleWidth, volHeight);
      }
    });
  }

  // -- TOOLTIP --

  function setupTooltip(stock) {
    const canvas = document.getElementById(`chart-${stock.symbol}`);
    const tooltip = document.getElementById(`tooltip-${stock.symbol}`);

    canvas.onmousemove = function(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const priceHeight = CHART_HEIGHT - PADDING;
      const volumeHeight = VOLUME_HEIGHT;
      const padding = PADDING;

      const candles = stock.history;

      const candleStep = (canvas.width - 2 * padding) / candles.length;
      const candleIndex = Math.floor((mouseX - padding) / candleStep);

      if (candleIndex < 0 || candleIndex >= candles.length) {
        tooltip.style.display = "none";
        return;
      }
      const candle = candles[candleIndex];

      const dateStr = `Candle ${candleIndex + 1}`;
      const o = candle.open.toFixed(2);
      const h = candle.high.toFixed(2);
      const l = candle.low.toFixed(2);
      const c = candle.close.toFixed(2);
      const v = candle.volume ? candle.volume.toLocaleString() : "N/A";

      tooltip.style.left = (mouseX + 15) + "px";
      tooltip.style.top = (mouseY + 15) + "px";
      tooltip.style.display = "block";

      tooltip.innerHTML = `
        <b>${stock.symbol} - ${dateStr}</b><br/>
        Open: $${o}<br/>
        High: $${h}<br/>
        Low: $${l}<br/>
        Close: $${c}<br/>
        Volume: ${v}
      `;
    };

    canvas.onmouseleave = () => {
      tooltip.style.display = "none";
    };
  }

  // -- PRICE FLUCTUATION --

  function fluctuatePrices() {
    stocks.forEach(stock => {
      const last = stock.history[stock.history.length - 1];
      if (!last) return;

      // New candle
      let open = last.close;
      let change = (Math.random() - 0.5) * (stock.price * 0.02); // ~±2%
      let close = Math.max(1, open + change);
      let high = Math.max(open, close) + Math.random() * (stock.price * 0.01);
      let low = Math.min(open, close) - Math.random() * (stock.price * 0.01);
      high = Math.max(high, open, close);
      low = Math.min(low, open, close);

      const volume = Math.floor(100 + Math.random() * 1000);

      stock.price = close;
      stock.history.push({ open, high, low, close, volume });

      // Limit history length
      if (stock.history.length > 50) stock.history.shift();
    });
    renderStocks();
    renderPortfolio();
    updateBalance();
  }

  // -- TAB SWITCHING --

  const tabMarket = document.getElementById("tab-market");
  const tabPortfolio = document.getElementById("tab-portfolio");
  const marketView = document.getElementById("market-view");
  const portfolioView = document.getElementById("portfolio-view");

  tabMarket.onclick = () => {
    tabMarket.classList.add("active");
    tabPortfolio.classList.remove("active");
    marketView.style.display = "block";
    portfolioView.style.display = "none";
  };
  tabPortfolio.onclick = () => {
    tabPortfolio.classList.add("active");
    tabMarket.classList.remove("active");
    marketView.style.display = "none";
    portfolioView.style.display = "block";
    renderPortfolio();
  };

  // -- INITIALIZATION --

  // Seed initial history
  stocks.forEach(stock => {
    for (let i = 0; i < 50; i++) {
      const base = stock.price;
      stock.history.push({
        open: base,
        high: base,
        low: base,
        close: base,
        volume: 100 + Math.random() * 500
      });
    }
  });

  renderStocks();
  updateBalance();

  // Update prices every 4 seconds
  setInterval(() => {
    fluctuatePrices();
    processPendingOrders();
  }, 4000);

</script>

</body>
</html>
