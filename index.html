<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bee Tower Defense - Skill Tree & Varied Gameplay</title>
<style>
  /* --- Reset & base styles --- */
  body, html {
    margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #fff8e1;
    user-select: none;
    display: flex; flex-direction: column;
  }
  #game-container {
    display: flex; flex: 1; overflow: hidden;
  }
  canvas {
    background: linear-gradient(to bottom, #f7e5a2 0%, #e3c157 100%);
    box-shadow: 0 0 20px #d1a71b;
    border-radius: 8px;
    margin: 10px;
  }
  /* Sidebar styling */
  #sidebar {
    width: 320px;
    background: #fff3b0;
    border-left: 4px solid #d1a71b;
    box-shadow: inset -5px 0 10px rgba(209,167,27,0.3);
    padding: 15px;
    display: flex;
    flex-direction: column;
  }
  h2 {
    margin: 10px 0 8px 0;
    color: #6b4a00;
    font-weight: 700;
    font-size: 1.3em;
    user-select: none;
  }
  #stats, #skills, #log {
    background: #fff8d1;
    border: 2px solid #d1a71b;
    border-radius: 6px;
    padding: 8px;
    margin-bottom: 15px;
    flex-shrink: 0;
  }
  #stats {
    font-weight: 600;
    font-size: 1.1em;
  }
  #log {
    flex-grow: 1;
    font-size: 0.85em;
    line-height: 1.3em;
    overflow-y: auto;
    font-family: monospace;
    white-space: pre-wrap;
    background: #fff8d1cc;
  }
  button {
    cursor: pointer;
    border: none;
    background: #d1a71b;
    color: #4b3200;
    font-weight: 700;
    padding: 8px 12px;
    border-radius: 5px;
    box-shadow: 0 2px 5px #a57b00;
    margin-top: 5px;
    user-select: none;
    transition: background 0.3s ease;
  }
  button:disabled {
    background: #f0e3a0;
    cursor: not-allowed;
    box-shadow: none;
  }
  button:hover:not(:disabled) {
    background: #e3b800;
  }
  .tower-btn {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: 600;
    background: #f4d35e;
    border: 2px solid #d1a71b;
    margin-bottom: 8px;
    padding: 10px 14px;
    border-radius: 7px;
  }
  .tower-btn:hover {
    background: #e3c53a;
  }
  .tower-color {
    display: inline-block;
    width: 18px; height: 18px;
    border-radius: 50%;
    margin-right: 10px;
    border: 1px solid #aaa;
  }
  #upgrade-section {
    border: 2px solid #d1a71b;
    border-radius: 6px;
    padding: 10px;
    background: #fff8d1;
    user-select: none;
  }
  #upgrade-info {
    margin-bottom: 8px;
    font-size: 0.9em;
    color: #4b3200;
  }
  #skill-points {
    font-weight: 700;
    color: #6b4a00;
    margin-bottom: 10px;
  }
  .skill-node {
    background: #f4d35e;
    border: 2px solid #d1a71b;
    border-radius: 6px;
    margin-bottom: 10px;
    padding: 8px 10px;
    cursor: pointer;
    transition: background 0.25s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
  }
  .skill-node:hover:not(.locked) {
    background: #e3c53a;
  }
  .skill-node.locked {
    background: #f0e3a0;
    cursor: not-allowed;
    color: #888;
  }
  .skill-node .skill-name {
    font-weight: 600;
  }
  .skill-node .skill-level {
    font-weight: 700;
  }
  #tooltip {
    position: fixed;
    background: rgba(255, 255, 204, 0.9);
    border: 1px solid #d1a71b;
    border-radius: 5px;
    padding: 5px 8px;
    font-size: 0.85em;
    color: #5c4500;
    pointer-events: none;
    user-select: none;
    white-space: pre-wrap;
    display: none;
    max-width: 240px;
    z-index: 10;
  }
  /* Range circle */
  .range-circle {
    position: absolute;
    border: 2.5px solid #e7bb00cc;
    border-radius: 50%;
    pointer-events: none;
    box-shadow: 0 0 10px #e7bb00aa;
  }
</style>
</head>
<body>

<div id="game-container">
  <canvas id="game-canvas" width="900" height="600" aria-label="Game canvas"></canvas>
  <div id="sidebar" aria-label="Game sidebar">
    <h2>Stats</h2>
    <div id="stats" aria-live="polite" aria-atomic="true">
      <div>Level: <span id="level">1</span></div>
      <div>Honey: <span id="money">0</span></div>
      <div>Hive Health: <span id="health">20</span></div>
      <div>Enemies Remaining: <span id="enemies-left">0</span></div>
      <div>Modifiers: <span id="modifiers">None</span></div>
    </div>

    <h2>Towers</h2>
    <div id="tower-buttons">
      <!-- Buttons created by JS -->
    </div>

    <div id="upgrade-section" aria-label="Tower upgrade section">
      <h2>Upgrade Tower</h2>
      <div id="upgrade-info">Select a tower on the field</div>
      <button id="upgrade-btn" disabled>Upgrade Tower</button>
    </div>

    <h2>Skill Tree</h2>
    <div id="skill-points">Skill Points: 0</div>
    <div id="skills">
      <!-- Skill nodes created by JS -->
    </div>

    <h2>Game Log</h2>
    <pre id="game-log" aria-live="polite" aria-atomic="false"></pre>
  </div>
</div>

<div id="tooltip" role="tooltip"></div>

<script>
(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const moneyEl = document.getElementById('money');
  const healthEl = document.getElementById('health');
  const levelEl = document.getElementById('level');
  const enemiesLeftEl = document.getElementById('enemies-left');
  const modifiersEl = document.getElementById('modifiers');
  const gameLog = document.getElementById('game-log');
  const upgradeBtn = document.getElementById('upgrade-btn');
  const upgradeInfo = document.getElementById('upgrade-info');
  const towerButtonsContainer = document.getElementById('tower-buttons');
  const skillPointsEl = document.getElementById('skill-points');
  const skillsContainer = document.getElementById('skills');
  const tooltip = document.getElementById('tooltip');

  // Canvas dimensions
  const CANVAS_WIDTH = canvas.width;
  const CANVAS_HEIGHT = canvas.height;

  // Game variables
  let money = 100;
  let health = 20;
  let level = 1;
  let enemiesToSpawn = 0;
  let enemySpawnTimer = 0;
  let enemySpawnInterval = 1000;
  let towers = [];
  let enemies = [];
  let projectiles = [];
  let currentModifiers = [];
  let placingTowerType = null;
  let selectedTower = null;
  let levelInProgress = false;

  // Skill tree data
  const skillTree = {
    points: 0,
    skills: {
      all_damage: { name: "All Towers Damage +10%", level: 0, maxLevel: 5, effect: lvl => 1 + lvl * 0.1 },
      freezing_duration: { name: "Freezing Tower Duration +1s", level: 0, maxLevel: 3, effect: lvl => lvl * 1000 },
      sniper_range: { name: "Sniper Tower Range +20%", level: 0, maxLevel: 3, effect: lvl => 1 + lvl * 0.2 },
      poison_damage: { name: "Poison Tower Damage +5", level: 0, maxLevel: 4, effect: lvl => lvl * 5 }
    }
  };

  // Tower definitions
  const towerTypes = {
    basic: {
      name: "Basic Tower",
      cost: 50,
      baseDamage: 8,
      range: 100,
      fireRate: 800,
      color: '#ffcc00',
      projectileColor: '#ffd700',
      maxLevel: 5,
      upgradeCost: 40,
      description: "Reliable shooter with balanced stats."
    },
    freezing: {
      name: "Freezing Tower",
      cost: 80,
      baseDamage: 4,
      range: 90,
      fireRate: 1100,
      freezeDuration: 2000, // milliseconds
      color: '#00d2ff',
      projectileColor: '#00aaff',
      maxLevel: 4,
      upgradeCost: 60,
      description: "Slows enemies significantly."
    },
    poison: {
      name: "Poison Tower",
      cost: 100,
      baseDamage: 2,
      range: 110,
      fireRate: 1300,
      poisonDamage: 2,
      poisonDuration: 3000,
      color: '#6b9e0e',
      projectileColor: '#a7d30c',
      maxLevel: 4,
      upgradeCost: 70,
      description: "Applies damage-over-time poison."
    },
    sniper: {
      name: "Sniper Tower",
      cost: 150,
      baseDamage: 25,
      range: 220,
      fireRate: 2500,
      color: '#aa0044',
      projectileColor: '#ff007f',
      maxLevel: 3,
      upgradeCost: 100,
      description: "Long-range high damage but slow fire rate."
    }
  };

  // Enemy definitions
  const enemyTypes = {
    normal: {
      name: "Wasp",
      maxHealth: 20,
      speed: 70,
      radius: 14,
      color: '#ffcc33',
      reward: 8,
      armor: 0,
      flying: false
    },
    flying: {
      name: "Flying Wasp",
      maxHealth: 15,
      speed: 110,
      radius: 12,
      color: '#66ccff',
      reward: 10,
      armor: 0,
      flying: true
    },
    armored: {
      name: "Armored Wasp",
      maxHealth: 40,
      speed: 50,
      radius: 16,
      color: '#996633',
      reward: 15,
      armor: 3,
      flying: false
    }
  };

  // Two predefined paths (arrays of points)
  const paths = [
    [ // Path 1 - zigzag
      { x: 30, y: 570 },
      { x: 30, y: 400 },
      { x: 300, y: 400 },
      { x: 300, y: 200 },
      { x: 600, y: 200 },
      { x: 600, y: 400 },
      { x: 870, y: 400 },
      { x: 870, y: 570 }
    ],
    [ // Path 2 - straight with bends
      { x: 30, y: 570 },
      { x: 30, y: 320 },
      { x: 500, y: 320 },
      { x: 500, y: 100 },
      { x: 870, y: 100 },
      { x: 870, y: 570 }
    ]
  ];

  let currentPath = paths[0];

  // Game modifiers (for fun, can be expanded)
  const possibleModifiers = [
    { name: "Honey Boost", description: "Earn 25% more honey", apply: () => moneyMultiplier = 1.25, remove: () => moneyMultiplier = 1 },
    { name: "Speed Frenzy", description: "Enemies spawn 30% faster", apply: () => enemySpawnIntervalMultiplier = 0.7, remove: () => enemySpawnIntervalMultiplier = 1 },
    { name: "Cold Snap", description: "Enemies slow randomly", apply: () => coldSnapActive = true, remove: () => coldSnapActive = false },
  ];

  // Modifier variables
  let moneyMultiplier = 1;
  let enemySpawnIntervalMultiplier = 1;
  let coldSnapActive = false;

  // Utility functions
  function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  /* --- Tower class --- */
  class Tower {
    constructor(type, x, y) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.level = 1;
      this.cooldown = 0;
    }
    get data() {
      return towerTypes[this.type];
    }
    get range() {
      let baseRange = this.data.range;
      if(this.type === 'sniper') {
        baseRange *= skillTree.skills.sniper_range.effect(skillTree.skills.sniper_range.level);
      }
      return baseRange + (this.level - 1) * 12;
    }
    get damage() {
      let baseDamage = this.data.baseDamage + (this.level - 1) * 3;
      // Apply global all_damage skill bonus
      baseDamage *= skillTree.skills.all_damage.effect(skillTree.skills.all_damage.level);
      if(this.type === 'poison') {
        baseDamage += skillTree.skills.poison_damage.level * 5;
      }
      return baseDamage;
    }
    get fireRate() {
      return this.data.fireRate * Math.max(0.4, 1 - (this.level - 1) * 0.1);
    }
    get upgradeCost() {
      return this.data.upgradeCost * this.level;
    }
    canUpgrade() {
      return this.level < this.data.maxLevel;
    }
    upgrade() {
      if (!this.canUpgrade()) return false;
      if (money < this.upgradeCost) return false;
      money -= this.upgradeCost;
      this.level++;
      log(`Upgraded ${this.data.name} to level ${this.level}.`);
      playSound('upgrade');
      return true;
    }
    shoot(target) {
      if (this.cooldown > 0) return false;
      this.cooldown = this.fireRate;
      projectiles.push(new Projectile(this, target));
      playSound('shoot');
      return true;
    }
    update(delta) {
      if(this.cooldown > 0) this.cooldown -= delta;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // Base circle
      ctx.fillStyle = this.data.color;
      ctx.beginPath();
      ctx.arc(0, 0, 18 + this.level * 2, 0, Math.PI * 2);
      ctx.fill();

      // Bee body ellipse
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(0, 0, 10, 14, 0, 0, Math.PI * 2);
      ctx.fill();

      // Stripes
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      for(let i=-8; i<=8; i+=5) {
        ctx.beginPath();
        ctx.moveTo(i, -14);
        ctx.lineTo(i, 14);
        ctx.stroke();
      }

      // Wings for freezing tower
      if(this.type === 'freezing') {
        ctx.fillStyle = 'rgba(0,191,255,0.5)';
        ctx.beginPath();
        ctx.ellipse(-8, -8, 7, 12, -Math.PI/6, 0, Math.PI*2);
        ctx.ellipse(8, -8, 7, 12, Math.PI/6, 0, Math.PI*2);
        ctx.fill();
      } else {
        // Wings normal
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath();
        ctx.ellipse(-8, -8, 6, 10, -Math.PI/6, 0, Math.PI*2);
        ctx.ellipse(8, -8, 6, 10, Math.PI/6, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();

      // Draw range circle if selected or placing this tower type
      if(selectedTower === this || placingTowerType === this.type) {
        ctx.strokeStyle = '#e7bb00cc';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  /* --- Projectile class --- */
  class Projectile {
    constructor(tower, target) {
      this.tower = tower;
      this.x = tower.x;
      this.y = tower.y;
      this.target = target;
      this.speed = 350;
      this.hit = false;
      this.color = tower.data.projectileColor;
      this.type = tower.type;
      this.damage = tower.damage;
      this.freezeDuration = tower.type === 'freezing' ? tower.data.freezeDuration + skillTree.skills.freezing_duration.effect(skillTree.skills.freezing_duration.level) : 0;
      this.poisonDamage = tower.type === 'poison' ? tower.data.poisonDamage + skillTree.skills.poison_damage.effect(skillTree.skills.poison_damage.level) : 0;
      this.poisonDuration = tower.type === 'poison' ? tower.data.poisonDuration : 0;
    }
    update(delta) {
      if(this.hit) return;
      let dx = this.target.x - this.x;
      let dy = this.target.y - this.y;
      let dist = Math.hypot(dx, dy);
      if(dist < this.speed * delta / 1000) {
        this.x = this.target.x;
        this.y = this.target.y;
        this.hit = true;
        this.target.takeDamage(this.damage, this);
      } else {
        this.x += dx / dist * this.speed * delta / 1000;
        this.y += dy / dist * this.speed * delta / 1000;
      }
    }
    draw(ctx) {
      if(this.hit) return;
      ctx.save();
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  /* --- Enemy class --- */
  class Enemy {
    constructor(type) {
      this.type = type;
      this.data = enemyTypes[type];
      this.x = currentPath[0].x;
      this.y = currentPath[0].y;
      this.health = this.data.maxHealth;
      this.speed = this.data.speed;
      this.radius = this.data.radius;
      this.pathIndex = 0;
      this.isDead = false;
      this.flying = this.data.flying;
      this.armor = this.data.armor || 0;
      this.poisoned = false;
      this.poisonTimer = 0;
      this.poisonDamagePerTick = 0;
      this.poisonTickInterval = 500;
      this.poisonTickCounter = 0;
    }
    takeDamage(amount, projectile) {
      // Apply armor reduction for physical damage (everything except poison)
      let effectiveDamage = amount;
      if(projectile.type !== 'poison') {
        effectiveDamage = Math.max(0, amount - this.armor);
      }
      this.health -= effectiveDamage;
      if(projectile.type === 'freezing' && this.flying === false) {
        this.frozenUntil = performance.now() + projectile.freezeDuration;
      }
      if(projectile.type === 'poison') {
        this.poisoned = true;
        this.poisonTimer = projectile.poisonDuration;
        this.poisonDamagePerTick = projectile.poisonDamage;
      }
      if(this.health <= 0) {
        this.die();
      }
    }
    die() {
      this.isDead = true;
      money += this.data.reward * moneyMultiplier;
      log(`Enemy ${this.data.name} killed! +${Math.floor(this.data.reward * moneyMultiplier)} honey.`);
      playSound('enemy_die');
    }
    update(delta) {
      if(this.isDead) return;
      // Poison damage ticking
      if(this.poisoned) {
        this.poisonTimer -= delta;
        this.poisonTickCounter += delta;
        if(this.poisonTickCounter >= this.poisonTickInterval) {
          this.poisonTickCounter -= this.poisonTickInterval;
          this.health -= this.poisonDamagePerTick;
          if(this.health <= 0) {
            this.die();
            return;
          }
        }
        if(this.poisonTimer <= 0) {
          this.poisoned = false;
        }
      }

      // Movement
      if(this.frozenUntil && performance.now() < this.frozenUntil) {
        // Slowed - move at half speed
        this.move(delta * 0.5);
      } else {
        this.move(delta);
      }
    }
    move(delta) {
      if(this.pathIndex >= currentPath.length - 1) {
        // Reached hive - damage player
        health -= 1;
        this.isDead = true;
        log(`An enemy reached the hive! Hive health: ${health}`);
        playSound('damage');
        if(health <= 0) {
          gameOver();
        }
        return;
      }
      const targetPoint = currentPath[this.pathIndex + 1];
      let dx = targetPoint.x - this.x;
      let dy = targetPoint.y - this.y;
      let dist = Math.hypot(dx, dy);
      if(dist < this.speed * delta / 1000) {
        this.x = targetPoint.x;
        this.y = targetPoint.y;
        this.pathIndex++;
      } else {
        this.x += dx / dist * this.speed * delta / 1000;
        this.y += dy / dist * this.speed * delta / 1000;
      }
    }
    draw(ctx) {
      if(this.isDead) return;
      ctx.save();
      ctx.translate(this.x, this.y);

      // Body circle
      ctx.fillStyle = this.data.color;
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();

      // Wings if flying
      if(this.flying) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(-this.radius/2, -this.radius, this.radius/1.2, this.radius/2, -Math.PI/8, 0, Math.PI * 2);
        ctx.ellipse(this.radius/2, -this.radius, this.radius/1.2, this.radius/2, Math.PI/8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Health bar
      ctx.fillStyle = '#222';
      ctx.fillRect(-this.radius, -this.radius - 10, this.radius*2, 5);
      ctx.fillStyle = '#e62e2e';
      const hpWidth = (this.health / this.data.maxHealth) * this.radius * 2;
      ctx.fillRect(-this.radius, -this.radius - 10, hpWidth, 5);

      ctx.restore();
    }
  }

  /* --- Game State --- */
  function log(msg) {
    const timeStr = new Date().toLocaleTimeString();
    gameLog.textContent += `[${timeStr}] ${msg}\n`;
    gameLog.scrollTop = gameLog.scrollHeight;
  }

  // Sound effects using simple beep sounds
  function playSound(name) {
    // Basic beep sounds with Web Audio API
    try {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      if(name === 'shoot') {
        osc.frequency.value = 800;
        gainNode.gain.value = 0.1;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
      } else if(name === 'enemy_die') {
        osc.frequency.value = 200;
        gainNode.gain.value = 0.2;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.25);
      } else if(name === 'upgrade') {
        osc.frequency.value = 1200;
        gainNode.gain.value = 0.1;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
      } else if(name === 'damage') {
        osc.frequency.value = 300;
        gainNode.gain.value = 0.15;
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
      }
    } catch(e) {
      // AudioContext not supported or blocked
    }
  }

  /* --- Tower placement and selection --- */
  function canPlaceTower(x, y) {
    // Check near path - can't place too close
    for(let i=0; i<currentPath.length-1; i++) {
      const a = currentPath[i];
      const b = currentPath[i+1];
      if(distanceToSegment({x,y}, a, b) < 40) return false;
    }
    // Check towers not overlapping
    for(const t of towers) {
      if(distance(t, {x,y}) < 45) return false;
    }
    // Inside canvas
    if(x < 30 || y < 30 || x > CANVAS_WIDTH-30 || y > CANVAS_HEIGHT-30) return false;
    return true;
  }

  function distanceToSegment(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if(l2 === 0) return distance(p, v);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return distance(p, {x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y)});
  }

  /* --- Game Logic --- */
  function spawnEnemy() {
    if(enemiesToSpawn <= 0) return;
    // Choose enemy type based on level and random chance
    let type;
    if(level < 3) type = 'normal';
    else if(level < 6) type = Math.random() < 0.7 ? 'normal' : 'flying';
    else {
      const r = Math.random();
      if(r < 0.5) type = 'normal';
      else if(r < 0.8) type = 'flying';
      else type = 'armored';
    }
    enemies.push(new Enemy(type));
    enemiesToSpawn--;
  }

  function startLevel(lvl) {
    if(levelInProgress) return;
    levelInProgress = true;

    // Pick random path for the level
    currentPath = paths[Math.floor(Math.random() * paths.length)];

    // Determine enemies count and spawn rate
    enemiesToSpawn = 5 + lvl * 3;
    enemySpawnInterval = 1000 * Math.max(0.4, 1 - lvl * 0.03);
    enemySpawnInterval *= enemySpawnIntervalMultiplier;

    log(`Level ${lvl} started!`);
    // Apply random modifiers (0-2)
    currentModifiers = [];
    modifiersEl.textContent = 'None';
    if(lvl > 1) {
      const count = Math.floor(Math.random() * 3);
      if(count > 0) {
        for(let i=0; i<count; i++) {
          const mod = possibleModifiers[Math.floor(Math.random() * possibleModifiers.length)];
          if(!currentModifiers.includes(mod)) {
            currentModifiers.push(mod);
            mod.apply();
          }
        }
        modifiersEl.textContent = currentModifiers.map(m => m.name).join(', ');
      }
    }
    updateUI();
  }

  function endLevel() {
    levelInProgress = false;
    // Remove modifiers
    for(const mod of currentModifiers) {
      mod.remove();
    }
    currentModifiers = [];
    skillTree.points++;
    log(`Level ${level} completed! You earned a skill point.`);
    skillPointsEl.textContent = `Skill Points: ${skillTree.points}`;
    level++;
    updateUI();
    setTimeout(() => startLevel(level), 3000);
  }

  function gameOver() {
    alert('Your hive has been destroyed! Game Over.');
    resetGame();
  }

  function resetGame() {
    money = 100;
    health = 20;
    level = 1;
    towers = [];
    enemies = [];
    projectiles = [];
    skillTree.points = 0;
    for(let key in skillTree.skills) skillTree.skills[key].level = 0;
    moneyMultiplier = 1;
    enemySpawnIntervalMultiplier = 1;
    coldSnapActive = false;
    currentModifiers = [];
    levelInProgress = false;
    log('Game reset.');
    skillPointsEl.textContent = 'Skill Points: 0';
    updateUI();
    startLevel(level);
  }

  /* --- UI Helpers --- */
  function updateUI() {
    moneyEl.textContent = Math.floor(money);
    healthEl.textContent = health;
    levelEl.textContent = level;
    enemiesLeftEl.textContent = enemiesToSpawn + enemies.length;
    skillPointsEl.textContent = `Skill Points: ${skillTree.points}`;
  }

  function logSkillTree() {
    skillsContainer.innerHTML = '';
    for(const [key, skill] of Object.entries(skillTree.skills)) {
      const node = document.createElement('div');
      node.className = 'skill-node';
      if(skill.level >= skill.maxLevel) {
        node.classList.add('locked');
      }
      node.innerHTML = `<span class="skill-name" title="${skill.name}">${skill.name}</span> <span class="skill-level">Lv. ${skill.level}/${skill.maxLevel}</span>`;
      node.addEventListener('click', () => {
        if(skill.level >= skill.maxLevel) return;
        if(skillTree.points <= 0) return;
        skill.level++;
        skillTree.points--;
        log(`Skill "${skill.name}" upgraded to level ${skill.level}.`);
        skillPointsEl.textContent = `Skill Points: ${skillTree.points}`;
        logSkillTree();
      });
      node.addEventListener('mouseenter', (e) => {
        tooltip.style.display = 'block';
        tooltip.textContent = skill.name + `\nLevel: ${skill.level}/${skill.maxLevel}`;
      });
      node.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });
      skillsContainer.appendChild(node);
    }
  }

  /* --- Tower buttons --- */
  function setupTowerButtons() {
    towerButtonsContainer.innerHTML = '';
    for(const [key, tower] of Object.entries(towerTypes)) {
      const btn = document.createElement('button');
      btn.className = 'tower-btn';
      btn.innerHTML = `<div><span class="tower-color" style="background:${tower.color}"></span> ${tower.name} (${tower.cost} honey)</div>`;
      btn.title = tower.description;
      btn.addEventListener('click', () => {
        placingTowerType = key;
        upgradeBtn.disabled = true;
        upgradeInfo.textContent = `Placing ${tower.name}. Click on valid spot on map.`;
      });
      btn.addEventListener('mouseenter', (e) => {
        tooltip.style.display = 'block';
        tooltip.textContent = `${tower.name}\nCost: ${tower.cost} honey\n${tower.description}`;
        positionTooltip(e);
      });
      btn.addEventListener('mousemove', positionTooltip);
      btn.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });
      towerButtonsContainer.appendChild(btn);
    }
  }

  /* --- Tower selection & upgrade --- */
  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if(placingTowerType) {
      if(canPlaceTower(mouseX, mouseY)) {
        const towerCost = towerTypes[placingTowerType].cost;
        if(money >= towerCost) {
          money -= towerCost;
          towers.push(new Tower(placingTowerType, mouseX, mouseY));
          log(`Placed ${towerTypes[placingTowerType].name} tower.`);
          placingTowerType = null;
          upgradeBtn.disabled = true;
          upgradeInfo.textContent = 'Select a tower on the field';
          playSound('upgrade');
        } else {
          alert('Not enough honey!');
        }
      } else {
        alert('Invalid tower position.');
      }
    } else {
      // Select tower if clicked near one
      selectedTower = null;
      for(let t of towers) {
        if(distance(t, {x: mouseX, y: mouseY}) < 25) {
          selectedTower = t;
          break;
        }
      }
      if(selectedTower) {
        upgradeBtn.disabled = !selectedTower.canUpgrade() || money < selectedTower.upgradeCost;
        upgradeInfo.innerHTML = `${selectedTower.data.name} (Lvl ${selectedTower.level})<br>Upgrade Cost: ${selectedTower.upgradeCost} honey<br><br>${selectedTower.data.description}`;
      } else {
        upgradeBtn.disabled = true;
        upgradeInfo.textContent = 'Select a tower on the field';
      }
    }
    updateUI();
  });

  upgradeBtn.addEventListener('click', () => {
    if(selectedTower && selectedTower.canUpgrade() && money >= selectedTower.upgradeCost) {
      if(selectedTower.upgrade()) {
        upgradeBtn.disabled = !selectedTower.canUpgrade() || money < selectedTower.upgradeCost;
        upgradeInfo.innerHTML = `${selectedTower.data.name} (Lvl ${selectedTower.level})<br>Upgrade Cost: ${selectedTower.upgradeCost} honey<br><br>${selectedTower.data.description}`;
        updateUI();
      }
    }
  });

  /* --- Tooltip positioning --- */
  function positionTooltip(e) {
    const offset = 15;
    const tooltipRect = tooltip.getBoundingClientRect();
    let x = e.clientX + offset;
    let y = e.clientY + offset;
    if(x + tooltipRect.width > window.innerWidth) {
      x = e.clientX - tooltipRect.width - offset;
    }
    if(y + tooltipRect.height > window.innerHeight) {
      y = e.clientY - tooltipRect.height - offset;
    }
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
  }

  /* --- Game Loop --- */
  let lastTime = performance.now();
  function gameLoop(time = performance.now()) {
    const delta = time - lastTime;
    lastTime = time;

    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw path
    ctx.strokeStyle = '#d1a71b';
    ctx.lineWidth = 15;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    for(let p of currentPath) ctx.lineTo(p.x, p.y);
ctx.stroke();

// Update and draw towers
for(const t of towers) {
  t.update(delta);
  t.draw(ctx);
}

// Update and draw projectiles
for(let p of projectiles) p.update(delta);
projectiles = projectiles.filter(p => !p.hit);
for(let p of projectiles) p.draw(ctx);

// Update and draw enemies
for(const e of enemies) e.update(delta);
enemies = enemies.filter(e => !e.isDead);
for(const e of enemies) e.draw(ctx);

// Enemy spawn
enemySpawnTimer += delta;
if(enemySpawnTimer > enemySpawnInterval) {
  spawnEnemy();
  enemySpawnTimer = 0;
}

// Check if wave cleared
if(levelInProgress && enemiesToSpawn <= 0 && enemies.length === 0) {
  endLevel();
}

updateUI();
logSkillTree();
requestAnimationFrame(gameLoop);
