<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stock Market Simulator with Candlestick Charts</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f0f2f5;
    margin: 0; padding: 20px;
    color: #222;
  }
  h1 {
    text-align: center;
    color: #2c3e50;
  }
  #balance {
    font-size: 1.2em;
    margin-bottom: 20px;
    text-align: center;
  }
  #stocks {
    max-width: 1000px;
    margin: 0 auto 20px auto;
    border-collapse: collapse;
    width: 100%;
  }
  #stocks th, #stocks td {
    border: 1px solid #ccc;
    padding: 8px 12px;
    text-align: center;
    vertical-align: middle;
  }
  #stocks th {
    background-color: #2980b9;
    color: white;
  }
  button {
    background-color: #27ae60;
    border: none;
    padding: 6px 12px;
    color: white;
    cursor: pointer;
    border-radius: 4px;
    font-weight: bold;
    transition: background-color 0.3s;
  }
  button:hover {
    background-color: #1e8449;
  }
  input[type=number] {
    width: 60px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #aaa;
    text-align: center;
  }
  #log {
    max-width: 1000px;
    margin: 0 auto;
    background: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    height: 140px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 14px;
    color: #34495e;
  }
  canvas.priceChart {
    display: block;
    margin: 8px auto 4px auto;
    width: 300px;
    height: 100px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #fff;
  }
</style>
</head>
<body>
  <h1>Stock Market Simulator with Candlestick Charts</h1>
  <div id="balance">Cash: $1000.00 | Portfolio Value: $0.00 | Total: $1000.00</div>
  <table id="stocks">
    <thead>
      <tr>
        <th>Stock</th>
        <th>Price ($)</th>
        <th>Price Chart</th>
        <th>Your Shares</th>
        <th>Buy</th>
        <th>Sell</th>
      </tr>
    </thead>
    <tbody id="stockBody"></tbody>
  </table>
  <div id="log"></div>

<script>
  let cash = 1000;

  // Each candle contains open, high, low, close, volume
  const stocks = [
    { symbol: "APL", name: "Apple", price: 150, owned: 0, history: [] },
    { symbol: "GGL", name: "Google", price: 2800, owned: 0, history: [] },
    { symbol: "TSL", name: "Tesla", price: 720, owned: 0, history: [] },
    { symbol: "AMZ", name: "Amazon", price: 3400, owned: 0, history: [] },
    { symbol: "MSF", name: "Microsoft", price: 300, owned: 0, history: [] },
  ];

  const balanceEl = document.getElementById("balance");
  const stockBody = document.getElementById("stockBody");
  const log = document.getElementById("log");

  // Format number as currency string
  function formatMoney(num) {
    return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  // Update UI balance
  function updateBalance() {
    let portfolioValue = stocks.reduce((sum, s) => sum + s.price * s.owned, 0);
    let total = cash + portfolioValue;
    balanceEl.textContent = `Cash: $${formatMoney(cash)} | Portfolio Value: $${formatMoney(portfolioValue)} | Total: $${formatMoney(total)}`;
  }

  // Log event
  function logEvent(text) {
    const time = new Date().toLocaleTimeString();
    log.textContent = `[${time}] ${text}\n` + log.textContent;
  }

  function createStockRow(stock) {
    const tr = document.createElement("tr");
    tr.id = `row-${stock.symbol}`;

    const tdSymbol = document.createElement("td");
    tdSymbol.textContent = `${stock.name} (${stock.symbol})`;

    const tdPrice = document.createElement("td");
    tdPrice.id = `price-${stock.symbol}`;
    tdPrice.textContent = formatMoney(stock.price);

    const tdChart = document.createElement("td");
    const canvas = document.createElement("canvas");
    canvas.className = "priceChart";
    canvas.id = `chart-${stock.symbol}`;
    canvas.width = 300;
    canvas.height = 100;
    tdChart.appendChild(canvas);

    const tdOwned = document.createElement("td");
    tdOwned.id = `owned-${stock.symbol}`;
    tdOwned.textContent = stock.owned;

    const tdBuy = document.createElement("td");
    const buyInput = document.createElement("input");
    buyInput.type = "number";
    buyInput.min = "1";
    buyInput.value = "1";
    buyInput.id = `buy-input-${stock.symbol}`;
    buyInput.style.marginRight = "6px";
    const buyBtn = document.createElement("button");
    buyBtn.textContent = "Buy";
    buyBtn.onclick = () => buyStock(stock.symbol, buyInput.value);
    tdBuy.appendChild(buyInput);
    tdBuy.appendChild(buyBtn);

    const tdSell = document.createElement("td");
    const sellInput = document.createElement("input");
    sellInput.type = "number";
    sellInput.min = "1";
    sellInput.value = "1";
    sellInput.id = `sell-input-${stock.symbol}`;
    sellInput.style.marginRight = "6px";
    const sellBtn = document.createElement("button");
    sellBtn.textContent = "Sell";
    sellBtn.onclick = () => sellStock(stock.symbol, sellInput.value);
    tdSell.appendChild(sellInput);
    tdSell.appendChild(sellBtn);

    tr.appendChild(tdSymbol);
    tr.appendChild(tdPrice);
    tr.appendChild(tdChart);
    tr.appendChild(tdOwned);
    tr.appendChild(tdBuy);
    tr.appendChild(tdSell);

    return tr;
  }

  function renderStocks() {
    stockBody.innerHTML = "";
    stocks.forEach(stock => {
      stockBody.appendChild(createStockRow(stock));
    });
  }

  function buyStock(symbol, amountStr) {
    const amount = parseInt(amountStr);
    if (isNaN(amount) || amount < 1) {
      alert("Enter a valid buy amount");
      return;
    }
    const stock = stocks.find(s => s.symbol === symbol);
    const cost = stock.price * amount;
    if (cost > cash) {
      alert(`Not enough cash to buy ${amount} shares of ${stock.symbol}`);
      return;
    }
    stock.owned += amount;
    cash -= cost;
    document.getElementById(`owned-${symbol}`).textContent = stock.owned;
    updateBalance();
    logEvent(`Bought ${amount} shares of ${stock.symbol} for $${formatMoney(cost)}`);
  }

  function sellStock(symbol, amountStr) {
    const amount = parseInt(amountStr);
    if (isNaN(amount) || amount < 1) {
      alert("Enter a valid sell amount");
      return;
    }
    const stock = stocks.find(s => s.symbol === symbol);
    if (amount > stock.owned) {
      alert(`You don't own ${amount} shares of ${stock.symbol}`);
      return;
    }
    const gain = stock.price * amount;
    stock.owned -= amount;
    cash += gain;
    document.getElementById(`owned-${symbol}`).textContent = stock.owned;
    updateBalance();
    logEvent(`Sold ${amount} shares of ${stock.symbol} for $${formatMoney(gain)}`);
  }

  // Draw candlestick chart for a stock
  function drawCandlestickChart(stock) {
    const canvas = document.getElementById(`chart-${stock.symbol}`);
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const candles = stock.history;
    if (candles.length < 2) return;

    const w = canvas.width;
    const h = canvas.height;
    const padding = 20;
    const candleWidth = (w - 2 * padding) / candles.length * 0.7;

    // Find min and max prices in history for scaling
    let minPrice = Math.min(...candles.map(c => c.low));
    let maxPrice = Math.max(...candles.map(c => c.high));
    if (minPrice === maxPrice) maxPrice = minPrice + 1;

    // Helpers to scale prices to canvas y
    function scaleY(price) {
      return h - padding - ((price - minPrice) / (maxPrice - minPrice)) * (h - 2 * padding);
    }

    // Draw grid lines horizontally
    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 1;
    ctx.font = "10px monospace";
    ctx.fillStyle = "#666";
    ctx.textAlign = "right";
    for(let i=0; i<=4; i++) {
      let price = minPrice + (maxPrice - minPrice) * i / 4;
      let y = scaleY(price);
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(w - padding, y);
      ctx.stroke();
      ctx.fillText(price.toFixed(2), padding - 5, y + 3);
    }

    // Draw candles
    candles.forEach((candle, i) => {
      const x = padding + i * ((w - 2 * padding) / candles.length) + ((w - 2 * padding) / candles.length - candleWidth) / 2;
      const openY = scaleY(candle.open);
      const closeY = scaleY(candle.close);
      const highY = scaleY(candle.high);
      const lowY = scaleY(candle.low);

      const candleColor = candle.close >= candle.open ? "green" : "red";

      // Wick
      ctx.strokeStyle = candleColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + candleWidth/2, highY);
      ctx.lineTo(x + candleWidth/2, lowY);
      ctx.stroke();

      // Body
      ctx.fillStyle = candleColor;
      const bodyY = Math.min(openY, closeY);
      const bodyHeight = Math.max(1, Math.abs(closeY - openY));
      ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
    });
  }

  // Generate new candle from last price - simulate OHLC & volume
  function generateNextCandle(stock) {
    const lastCandle = stock.history.length ? stock.history[stock.history.length - 1] : null;
    let open = lastCandle ? lastCandle.close : stock.price;
    let high = open;
    let low = open;
    let close = open;

    // Simulate price movement for OHLC
    const volatility = open * 0.05; // ~5% max move

    // Random open-close move
    close = open + (Math.random() * 2 - 1) * volatility;

    // High and low within open and close plus some noise
    high = Math.max(open, close) + Math.random() * volatility * 0.5;
    low = Math.min(open, close) - Math.random() * volatility * 0.5;

    // Clamp prices so none go below 1
    low = Math.max(1, low);
    close = Math.max(1, close);
    high = Math.max(high, low, close);

    return { open, high, low, close };
  }

  function fluctuatePrices() {
    stocks.forEach(stock => {
      // Add new candle
      const newCandle = generateNextCandle(stock);
      stock.history.push(newCandle);

      // Limit history size
      if (stock.history.length > 50) stock.history.shift();

      // Update current price to latest candle close
      stock.price = newCandle.close;

      // Update price UI
      const priceTd = document.getElementById(`price-${stock.symbol}`);
      if (priceTd) {
        priceTd.textContent = formatMoney(stock.price);
        priceTd.style.color = (newCandle.close >= newCandle.open) ? "green" : "red";
      }

      drawCandlestickChart(stock);
    });
    updateBalance();
  }

  // Initial setup
  stocks.forEach(stock => {
    // Seed initial history with stable candles
    for(let i=0; i<20; i++) {
      stock.history.push({ open: stock.price, high: stock.price, low: stock.price, close: stock.price });
    }
  });
  renderStocks();
  updateBalance();
  stocks.forEach(drawCandlestickChart);

  // Update every 5 seconds
  setInterval(fluctuatePrices, 5000);
</script>
</body>
</html>
